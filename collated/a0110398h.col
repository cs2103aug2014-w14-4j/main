//@author: a0110398h



	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\Task.java
	 */

package todothis.commons;


public class Task implements Comparable<Task> {
	private int taskID;
	private String labelName;
	private TDTDateAndTime dateAndTime;
	private String details;
	private boolean isHighPriority;
	private boolean isDone;
	private String remindDateTime;
	private TDTReminder reminder;
	
//---------------------Task constructor---------------------------------------
	/**
	 * Construct a Task object
	 * @param taskID
	 * @param labelName
	 * @param details
	 * @param dateAndTime
	 * @param p
	 */
	public Task(int taskID, String labelName, String details, TDTDateAndTime dateAndTime, boolean p) {
		this.setDetails(details);
		this.setTaskID(taskID);
		this.setLabelName(labelName);
		this.setDone(false);
		this.setHighPriority(p);
		this.setDateAndTime(dateAndTime);
		this.setRemindDateTime("null");
	}

	/**
	 * Construct a Task object
	 * @param taskID
	 * @param labelName
	 * @param details
	 * @param dateAndTime
	 * @param p
	 * @param done
	 * @param remindDateTime
	 */
	public Task(int taskID, String labelName, String details,
			TDTDateAndTime dateAndTime, boolean p,
			boolean done, String remindDateTime) {
		this.setDetails(details);
		this.setTaskID(taskID);
		this.setLabelName(labelName);
		this.setDone(done);
		this.setHighPriority(p);
		this.setDateAndTime(dateAndTime);
		this.setRemindDateTime(remindDateTime);
	}
	
	//-------------------------------------------------------------------------------




	@Override
	public int compareTo(Task task) {
		if (this.isHighPriority && !task.isHighPriority) {
			return -1;
		} else if(!this.isHighPriority && task.isHighPriority) {
			return 1;
		}
		else {
			if (this.getDateAndTime().compareTo(task.getDateAndTime()) == 1) {
				return 1;
			}
			else if (this.getDateAndTime().compareTo(task.getDateAndTime()) == -1) {
				return -1;
			}
			else {
				return 0;
			}
		}
	}
	
	/**
	 * Check if the task has a reminder.
	 * @return true if have reminder else false
	 */
	public boolean hasReminder() {
		return reminder != null;
	}
	
	//------------------Getters & Setters--------------------------------
	
	public int getTaskID() {
		return taskID;
	}
	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}
	public String getLabelName() {
		return labelName;
	}
	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}
	public String getDetails() {
		return details;
	}
	public void setDetails(String details) {
		this.details = details;
	}
	public boolean isHighPriority() {
		return isHighPriority;
	}
	public void setHighPriority(boolean isHighPriority) {
		this.isHighPriority = isHighPriority;
	}

	public boolean isDone() {
		return isDone;
	}
	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}


	public TDTDateAndTime getDateAndTime() {
		return dateAndTime;
	}


	public void setDateAndTime(TDTDateAndTime dateAndTime) {
		this.dateAndTime = dateAndTime;
	}


	public String getRemindDateTime() {
		return remindDateTime;
	}


	public void setRemindDateTime(String remindDateTime) {
		this.remindDateTime = remindDateTime;
	}


	public TDTReminder getReminder() {
		return reminder;
	}


	public void setReminder(TDTReminder reminder) {
		this.reminder = reminder;
	}
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\Task.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTReminder.java
	 */

package todothis.commons;

import java.awt.Toolkit;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.JOptionPane;

/**
 * TDTReminder class
 *
 */
public class TDTReminder {
	Timer timer;

	/**
	 * Construct a TDTReminder object
	 * 
	 * @param sec
	 *            Remaining time left to reminder timing in seconds.
	 * @param task
	 *            The task to be reminded
	 */
	public TDTReminder(long sec, Task task) {
		timer = new Timer();
		try {
			timer.schedule(new TDTReminderTask(task), sec * 1000);
		} catch (IllegalArgumentException e) {
			// Undoing a already past reminder
			task.setRemindDateTime("null");
			task.setReminder(null);
		}
	}

	/**
	 * Cancel the reminder.
	 */
	public void cancelReminder() {
		timer.cancel();
	}

	private class TDTReminderTask extends TimerTask {
		private Task task;

		public TDTReminderTask(Task task) {
			this.setTask(task);
		}

		public void run() {
			Toolkit.getDefaultToolkit().beep();
			JOptionPane.showMessageDialog(null, "REMINDER!\nTask: "
					+ getTask().getDetails());
			timer.cancel();
			getTask().setRemindDateTime("null");
			getTask().setReminder(null);
		}

		public Task getTask() {
			return task;
		}

		public void setTask(Task task) {
			this.task = task;
		}
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTReminder.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\gui\TDTGUI.java
	 */

package todothis.gui;

import java.awt.AWTException;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.MenuItem;
import java.awt.PopupMenu;
import java.awt.Rectangle;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;

import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.BoxLayout;
import javax.swing.InputMap;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.JTextPane;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.border.MatteBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.StyleSheet;

import todothis.commons.TDTCommons;
import todothis.commons.TDTDateMethods;
import todothis.commons.TDTTimeMethods;
import todothis.commons.Task;
import todothis.logic.TDTController;

public class TDTGUI extends JFrame implements DocumentListener {
	public static final Rectangle MINIMODE_SIZE = new Rectangle(300, 0, 500, 125);
	public static final Rectangle ORIGINAL_SIZE = new Rectangle(300, 100, 800, 600);
	private static final String COMMIT_ACTION = "commit";
	private static final long serialVersionUID = 1L;

	private static enum Mode {
		INSERT, COMPLETION
	};

	private Mode mode = Mode.INSERT;

	private TDTController control;
	private String userCommand;
	private ArrayList<String> commandHistory = new ArrayList<String>();
	private int historyPointer = 0;
	private JLabel commandLabel = new JLabel(" I want to: ");
	private JTextPane taskPane = new JTextPane();
	private JTextPane feedbackArea = new JTextPane();
	private JTextField commandField = new JTextField();
	private JPanel contentPane;
	private JLabel taskLabel = new JLabel();
	private JScrollPane scrollPane = new JScrollPane();
	private JPanel top1 = new JPanel();
	private JPanel top2 = new JPanel();

	private String css = ".datagrid table {background: \"white\"; text-align: center; width: 100%; } "
			+ ".datagrid {font: normal 12px/150% Candara, Helvetica, sans-serif; overflow: hidden; border: 4px solid #006699; }"
			+ ".datagrid table td  { text-align: left; color: #00496B; border: 1px solid white;border-left: 1px solid #5882FA; font-size: 13px; font-weight: normal; }"
			+ ".datagrid table .alt { background: #E1EEF4; color: #00496B; }"
			+ ".datagrid table .heading{ border-left: 1px solid #5882FA;border-right: 1px solid #5882FA; background: #BDBDBD}"
			+ ".datagrid table .heading th{ border: 1px solid white;}"
			+ ".datagrid table .overdue { background: #FC7C7C; color: white}"
			+ ".datagrid table .priority { background: #ff4040; color: white }"
			+ ".datagrid table tr .datetime{ font-size:12px }"
			+ ".datagrid table .target { border: 4px solid #0F0E0E }"
			+ ".datagrid table .clash { border: 4px solid #EEB111 }"
			+ ".datagrid table .priorityclash { border: 4px solid #EEB111; background: #ff4040; color: white }"
			+ ".datagrid table .overdueclash { border: 4px solid #EEB111; background: #FC7C7C; color: white }"
			+ ".datagrid table .altclash { border: 4px solid #EEB111; background: #E1EEF4; color: #00496B; }"
			+ ".datagrid table .prioritytarget { border: 4px solid #0F0E0E; background: #ff4040; color: white }"
			+ ".datagrid table .overduetarget { border: 4px solid #0F0E0E; background: #FC7C7C; color: white }"
			+ ".datagrid table .alttarget { border: 4px solid #0F0E0E; background: #E1EEF4; color: #00496B; }"
			+ ".datagrid table .taskId { width: 10%; }"
			+ ".datagrid table .dateTime { width: 35%; }"
			+ ".datagrid table .labelhead { width: 10%; }"
			+ ".datagrid table .done { background: #00ff7f; text-decoration: line-through}"
			+ ".datagrid table .donetarget { background: #00ff7f; text-decoration: line-through}"
			+ ".label{ color: #0174DF; font-size:15px font-family: Candara;}"
			+ ".helptable td { text-align: left; color: #00496B; border: 1px solid black;border-left: 1px solid #5882FA; font-size: 13px; font-weight: normal; }"
			+ ".helptable tr { text-align: left; color: #00496B; border: 1px solid black;border-left: 1px solid #5882FA; font-size: 13px; font-weight: normal; }"
			+ ".helptable th { text-align: left; color: #00496B; border: 1px solid black;border-left: 1px solid #5882FA; font-size: 13px; font-weight: normal; }";

	/**
	 * Create the frame.
	 */
	public TDTGUI() {
		control = new TDTController(TDTCommons.FILENAME);
		initContentPane();
		initCommandLabel();
		initCommandField();
		initTaskLabel();
		initTaskPane();
		initScrollPane();
		initFeedbackArea();
	}

	/**
	 * Initialize TodoThis
	 * 
	 * @return feedback/Welcome message
	 */
	public String doInit() {
		try {
			control.readAndInitialize();
		} catch (Exception e) {
			return "Unable to create todothis.txt";
		}
		setVisible(true);
		Image image = Toolkit.getDefaultToolkit().getImage("src/taeyeon.jpg");
		setIconImage(image);
		setTitle("TodoThis");

		taskPane.setText(displayTask(null, null));
		taskLabel.setText(" Current Label: " + control.getCurrLabel());
		return "Welcome to TodoThis!\nType \"help\" to learn more.";
	}

	/**
	 * Updates GUI
	 * 
	 * @param feedback
	 *  To be display at feedbackArea
	 * @param text
	 *  To be display at taskPane
	 */
	public void updateGUI(String feedback, String text) {
		taskLabel.setText(" Current Label: " + control.getCurrLabel());
		getFeedbackArea().setText(feedback);
		taskPane.setText(text);
		changeColorOfFeedbackArea(feedback);
	}

	// -------------------------------Display Format------------------------------

	protected String displayTask(ArrayList<Task> target, Task addedTask) {
		StringBuilder sb = new StringBuilder();
		String currLabel = control.getCurrLabel();
		Iterator<String> labelIter = control.getLabelIterator();
		ArrayList<Task> array;
		Iterator<String> hideIter = control.getHideIter();

		// Display task from current label first
		array = control.getTaskListFromLabel(currLabel);
		displayFormat(sb, currLabel, array, target, addedTask);

		while (labelIter.hasNext()) {
			String label = labelIter.next();
			if (!label.equals(currLabel)) {
				array = control.getTaskListFromLabel(label);
				displayFormat(sb, label, array, target, addedTask);
			}
		}
		while (hideIter.hasNext()) {
			String label = hideIter.next();
			array = control.getTaskListFromLabel(label);
			if (array != null) {
				sb.append("<span class = label><b>" + label + "("
						+ array.size() + ")" + "</b></span>: <br>");
			}
		}
		return sb.toString();
	}

	private void displayFormat(StringBuilder sb, String currLabel,
			ArrayList<Task> array, ArrayList<Task> target, Task addedTask) {
		if (array != null) {
			if (!control.isHideLabel(currLabel)) {
				sb.append("<span class = label><b>" + currLabel + "("
						+ array.size() + ")" + "</b></span>: <br>");
				for (int i = 0; i < array.size(); i++) {
					Task task = array.get(i);
					if (i == 0) {
						sb.append("<div class= datagrid><table>");
						sb.append("<tr class = heading> <th class = taskId>TaskID</th> "
								+ "<th>TaskDetails</th> "
								+ "<th class = dateTime>Date/Time</th> </tr>");
					}
					if (task.isDone()) {
						sb.append(displayTaskInRow(task, " class = done",
								target, addedTask));
					} else if (task.getDateAndTime().isOverdue()) {
						sb.append(displayTaskInRow(task, " class = overdue",
								target, addedTask));
					} else if (task.isHighPriority()) {
						sb.append(displayTaskInRow(task, " class = priority",
								target, addedTask));
					} else if (i % 2 == 0) {
						sb.append(displayTaskInRow(task, " class = alt",
								target, addedTask));
					} else {
						sb.append(displayTaskInRow(task, " class =", target,
								addedTask));
					}
				}
				sb.append("</table></div>");
			}
		}
	}

	private String displayTaskInRow(Task task, String type,
			ArrayList<Task> target, Task addedTask) {
		if (addedTask == task) {
			type = type + "target";
		}
		if (target != null) {
			if (target.contains(task)) {
				type = type + "clash";
			}
		}
		return "<tr" + type + "><td>" + task.getTaskID() + "</td><td>"
				+ task.getDetails() + "</td><td class = datetime>"
				+ task.getDateAndTime().display()
				+ checkIfHaveReminder(task.getRemindDateTime()) + "</td></tr>";
	}

	private String checkIfHaveReminder(String remind) {
		String res = "";
		if (!remind.equals("null")) {
			String[] temp = remind.split(" ");
			res = res + TDTDateMethods.changeToDayOfWeek(temp[0]) + " ";
			res = res + TDTDateMethods.changeDateFormatDisplay(temp[0]) + " ";
			res = res + TDTTimeMethods.changeTimeFormatDisplay(temp[1]);
			res = "Reminder: " + res;
		}
		return res;
	}

	protected String displaySearch(ArrayList<Task> searched) {
		Collections.sort(searched);
		Iterator<Task> iter = searched.iterator();
		StringBuilder res = new StringBuilder();
		int i = 0;
		res.append("<span class = \"label\"><b>SEARCH RESULTS</b></span>: <br>");
		res.append("<div class=\"datagrid\"><table>");
		res.append("<tr class = heading><th class = labelhead>Label</th> <th class = taskId>TaskID</th> "
				+ "<th>TaskDetails</th> <th class = dateTime>Date/Time</th> </tr>");
		while (iter.hasNext()) {
			Task next = iter.next();
			if (next.isDone()) {
				res.append(displaySearchTaskInRow(next, " class = done"));
			} else if (next.getDateAndTime().isOverdue()) {
				res.append(displaySearchTaskInRow(next, " class = overdue"));
			} else if (next.isHighPriority()) {
				res.append(displaySearchTaskInRow(next, " class = priority"));
			} else if (i % 2 == 0) {
				res.append(displaySearchTaskInRow(next, " class = alt"));
			} else {
				res.append(displaySearchTaskInRow(next, ""));
			}
			i++;
		}
		return res.toString();
	}

	private String displaySearchTaskInRow(Task next, String type) {
		return "<tr" + type + "><td>" + next.getLabelName() + "</td><td>"
				+ next.getTaskID() + "</td><td>" + next.getDetails()
				+ "</td><td class = \"datetime\">"
				+ next.getDateAndTime().display()
				+ checkIfHaveReminder(next.getRemindDateTime()) + "</td></tr>";
	}

	private void changeColorOfFeedbackArea(String feedback) {
		String[] feedbackParams = feedback.split(" ");
		if (feedbackParams.length > 0) {
			String firstWord = feedbackParams[0];
			if (firstWord.equals("Invalid")) {
				getFeedbackArea().setBackground(Color.pink);
			} else if (firstWord.equals("Clashes")) {
				getFeedbackArea().setBackground(Color.yellow);
			} else {
				getFeedbackArea().setBackground(Color.green);
			}
		} else {
			getFeedbackArea().setBackground(Color.green);
		}
	}

	// ----------------Component Initialization------------------------------------

	private void initTaskLabel() {
		top1.add(taskLabel, BorderLayout.SOUTH);
		taskLabel.setFocusable(false);
	}

	private void initFeedbackArea() {
		getFeedbackArea().setPreferredSize(new Dimension(100, 40));
		contentPane.add(getFeedbackArea(), BorderLayout.SOUTH);
		getFeedbackArea().setEditable(false);
		getFeedbackArea().setFocusable(false);
	}

	private void initScrollPane() {
		contentPane.add(getScrollPane(), BorderLayout.CENTER);
		getScrollPane().setRowHeaderView(taskPane);
		getScrollPane().setFocusable(true);
		getScrollPane().getViewport().setView(taskPane);
		getScrollPane().addKeyListener(new TDTKeyListener(this));
	}

	private void initTaskPane() {
		taskPane.setBackground(Color.white);
		HTMLEditorKit kit = new HTMLEditorKit();
		taskPane.setEditorKit(kit);
		StyleSheet styleSheet = kit.getStyleSheet();
		styleSheet.addRule(css);
		taskPane.setFocusable(false);
		taskPane.setEditable(false);
	}

	private void initCommandField() {
		getCommandField().setPreferredSize(new Dimension(100, 27));
		getCommandField().getDocument().addDocumentListener(this);
		InputMap im = getCommandField().getInputMap();
		ActionMap am = getCommandField().getActionMap();
		im.put(KeyStroke.getKeyStroke("RIGHT"), COMMIT_ACTION);
		am.put(COMMIT_ACTION, new CommitAction());
		top2.add(getCommandField());
		getCommandField().setColumns(10);
		getCommandField().setFocusable(true);
		getCommandField().addKeyListener(new TDTKeyListener(this));
	}

	private void initCommandLabel() {
		top2.add(commandLabel);
		commandLabel.setFocusable(false);
	}

	private void initContentPane() {
		setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
		setBounds(ORIGINAL_SIZE);
		contentPane = new JPanel();
		contentPane.setBorder(new MatteBorder(3, 3, 3, 3, (Color) new Color(0,
				0, 0)));
		contentPane.setLayout(new BorderLayout(0, 0));
		setContentPane(contentPane);
		contentPane.add(top1, BorderLayout.NORTH);
		top1.setLayout(new BorderLayout(0, 0));
		top1.add(top2);
		top2.setLayout(new BoxLayout(top2, BoxLayout.X_AXIS));
	}

	// ----------------------------- DocumentListener -----------------------------------
	@Override
	public void changedUpdate(DocumentEvent arg0) {
	}

	@Override
	public void insertUpdate(DocumentEvent ev) {
		if (ev.getLength() != 1) {
			return;
		}

		int pos = ev.getOffset();
		String content = null;
		try {
			content = getCommandField().getText(0, pos + 1);
		} catch (BadLocationException e) {
			System.out.println("Bad location.");
		}

		// Find where the word starts
		int w;
		for (w = pos; w >= 0; w--) {
			if (!Character.isLetter(content.charAt(w))) {
				break;
			}
		}
		if (pos - w < 2) {
			// Too few chars
			return;
		}

		String prefix = content.substring(w + 1).toUpperCase();
		int n = Collections.binarySearch(control.getAutoWords(), prefix);

		if (n < 0 && -n <= control.getAutoWords().size()) {
			String match = control.getAutoWords().get(-n - 1);
			if (match.toLowerCase().startsWith(prefix.toLowerCase())) {
				String completion = match.substring(pos - w).toLowerCase();
				SwingUtilities.invokeLater(new CompletionTask(completion,
						pos + 1));
			}
		} else {
			// Nothing found
			mode = Mode.INSERT;
		}

	}

	@Override
	public void removeUpdate(DocumentEvent arg0) {
	}

	private class CompletionTask implements Runnable {
		String completion;
		int position;

		CompletionTask(String completion, int position) {
			this.completion = completion;
			this.position = position;
		}

		public void run() {
			try {
				getCommandField().getDocument().insertString(position,
						completion, null);
			} catch (BadLocationException e) {
				System.out.println("Bad location error.");
			}
			getCommandField().setCaretPosition(position + completion.length());
			getCommandField().moveCaretPosition(position);
			mode = Mode.COMPLETION;
		}
	}

	private class CommitAction extends AbstractAction {
		private static final long serialVersionUID = 1L;

		public void actionPerformed(ActionEvent ev) {
			if (mode == Mode.COMPLETION) {
				int pos = getCommandField().getSelectionEnd();
				try {
					getCommandField().getDocument().insertString(pos, "", null);
				} catch (BadLocationException e) {
					System.out.println("Bad location error.");
				}
				getCommandField().setCaretPosition(pos);
				mode = Mode.INSERT;
			} else {
				getCommandField().setCaretPosition(
						Math.min(getCommandField().getCaretPosition() + 1,
								getCommandField().getText().length()));
			}
		}
	}

	// --------------------------------System Tray -----------------------------
	public void sysTray() {
		final TDTGUI gui = this;
		if (!SystemTray.isSupported()) {
			System.out.println("System tray is not supported !!! ");
			gui.control.writeToFile();
			System.exit(0);
		}
		SystemTray systemTray = SystemTray.getSystemTray();
		Image image = Toolkit.getDefaultToolkit().getImage("src/taeyeon.jpg");

		PopupMenu trayPopupMenu = new PopupMenu();
		MenuItem close = new MenuItem("Close");
		close.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				gui.control.writeToFile();
				System.exit(0);
			}
		});
		trayPopupMenu.add(close);
		TrayIcon trayIcon = new TrayIcon(image, "TodoThis", trayPopupMenu);
		trayIcon.addMouseListener(new MouseListener() {

			@Override
			public void mouseClicked(MouseEvent arg0) {
				if (arg0.getButton() == MouseEvent.BUTTON1) {
					gui.setVisible(true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent arg0) {
			}

			@Override
			public void mouseExited(MouseEvent arg0) {
			}

			@Override
			public void mousePressed(MouseEvent arg0) {
			}

			@Override
			public void mouseReleased(MouseEvent arg0) {
			}
		});
		trayIcon.setImageAutoSize(true);

		try {
			systemTray.add(trayIcon);
		} catch (AWTException awtException) {
			awtException.printStackTrace();
		}
	}

	// --------------------------Getters & Setters------------------------------------

	public ArrayList<String> getCommandHistory() {
		return commandHistory;
	}

	public void setCommandHistory(ArrayList<String> commandHistory) {
		this.commandHistory = commandHistory;
	}

	public int getHistoryPointer() {
		return historyPointer;
	}

	public void setHistoryPointer(int historyPointer) {
		this.historyPointer = historyPointer;
	}

	public String getUserCommand() {
		return userCommand;
	}

	public void setUserCommand(String userCommand) {
		this.userCommand = userCommand;
	}

	public TDTController getControl() {
		return control;
	}

	public void setControl(TDTController control) {
		this.control = control;
	}

	public JTextPane getFeedbackArea() {
		return feedbackArea;
	}

	public void setFeedbackArea(JTextPane feedbackArea) {
		this.feedbackArea = feedbackArea;
	}

	public JScrollPane getScrollPane() {
		return scrollPane;
	}

	public void setScrollPane(JScrollPane scrollPane) {
		this.scrollPane = scrollPane;
	}

	public JTextField getCommandField() {
		return commandField;
	}

	public void setCommandField(JTextField commandField) {
		this.commandField = commandField;
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\gui\TDTGUI.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\gui\TDTKeyListener.java
	 */

package todothis.gui;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import todothis.commons.TDTDateAndTime;
import todothis.commons.Task;
import todothis.logic.TDTController;

public class TDTKeyListener implements KeyListener {
	
	private static final int _SCROLLFACTOR = 30;
	private TDTGUI gui;

	public TDTKeyListener(TDTGUI gui) {
		this.gui = gui;
	}

	@Override
	public void keyPressed(KeyEvent arg0) {
		int keyCode = arg0.getKeyCode();
		int scrollVal = gui.getScrollPane().getVerticalScrollBar().getValue();
		
		if (arg0.isShiftDown() && keyCode == KeyEvent.VK_UP) {
			scrollTo(scrollVal - _SCROLLFACTOR);
		}
		
		if (arg0.isShiftDown() && keyCode == KeyEvent.VK_DOWN) {
			scrollTo(scrollVal + _SCROLLFACTOR);
		}
		
		if (arg0.isControlDown() && keyCode == KeyEvent.VK_Z) {
			String feedback = gui.getControl().executeCommand("undo");
			updateView(scrollVal, feedback);
		}
		
		if (arg0.isAltDown()  && keyCode == KeyEvent.VK_S) {
			String feedback = gui.getControl().executeCommand("show");
			gui.updateGUI(feedback, gui.displayTask(null, null));
			scrollTo(0);
		}
		
		if (arg0.isAltDown()  && keyCode == KeyEvent.VK_E) {
			gui.getControl().executeCommand("exit");
		}
		
		if (arg0.isAltDown() && keyCode == KeyEvent.VK_H) {
			String feedback = gui.getControl().executeCommand("hide");
			gui.updateGUI(feedback, gui.displayTask(null, null));
			scrollTo(0);
		}

		if (arg0.isControlDown() && keyCode == KeyEvent.VK_Y) {
			String feedback = gui.getControl().executeCommand("redo");
			updateView(scrollVal, feedback);
		}
		
		switch (keyCode) {
		case KeyEvent.VK_ENTER:
			renewCommandField();
			String feedback = gui.getControl().executeCommand(gui.getUserCommand());
			updateView(scrollVal, feedback);
			break;

		case KeyEvent.VK_UP:
			if(gui.getCommandField().hasFocus() && !arg0.isShiftDown()) {
				gui.setHistoryPointer(gui.getHistoryPointer() - 1);
				if (gui.getHistoryPointer() < 0) {
					gui.getCommandField().setText("");
					gui.setHistoryPointer(-1);
				} else {
					gui.getCommandField().setText(gui.getCommandHistory().get(
							gui.getHistoryPointer()));
				}
			}
			break;
		case KeyEvent.VK_DOWN:
			if(gui.getCommandField().hasFocus() && !arg0.isShiftDown()) {
				gui.setHistoryPointer(gui.getHistoryPointer() + 1);
				if (gui.getHistoryPointer() >= gui.getCommandHistory().size()) {
					gui.getCommandField().setText("");
					gui.setHistoryPointer(gui.getCommandHistory().size());
				} else {
					gui.getCommandField().setText(gui.getCommandHistory().get(
							gui.getHistoryPointer()));
				}
			}
			break;
		case KeyEvent.VK_SPACE:
			gui.setUserCommand(gui.getCommandField().getText());
			String[] words = gui.getUserCommand().split(" ");
			if (words.length == 2) {
				autoCompleteForEditLengthTwo(words);
			}
			if (words.length == 3) {
				autoCompleteForEditLengthThree(words);
			}
			break;
		case KeyEvent.VK_F1:
			gui.setBounds(TDTGUI.MINIMODE_SIZE);
			break;
		case KeyEvent.VK_F2:
			gui.setBounds(TDTGUI.ORIGINAL_SIZE);
			break;
		default:
			break;
		}
	}

	private void autoCompleteForEditLengthThree(String[] words) {
		if (words[0].equalsIgnoreCase("edit")) {
			try {
				int id = Integer.parseInt(words[2]);
				if (gui.getControl().isInLabelMap(words[1].toUpperCase())) {
					int size = gui.getControl().getLabelSize(words[1]);
					if (id > 0 && id <= size) {
						Task task = gui.getControl().getTask(words[1], id);
						TDTDateAndTime dat = task.getDateAndTime();
						String datString = getDateTimeStringForEdit(dat);
						gui.getCommandField().setText(gui.getUserCommand() + " "
								+ task.getDetails() + datString);
						
						highlightText();
					}
				}
			} catch (NumberFormatException e) {
				;//Do nothing if it is not number
			}
		}
	}

	private void autoCompleteForEditLengthTwo(String[] words) {
		if (words[0].equalsIgnoreCase("edit")) {
			try {
				int id = Integer.parseInt(words[1]);
				int size = gui.getControl().getLabelSize(gui.getControl().getCurrLabel());
				if (id > 0 && id <= size) {
					Task task = gui.getControl().getTask(gui.getControl().getCurrLabel(), id);
					TDTDateAndTime dat = task.getDateAndTime();
					String datString = getDateTimeStringForEdit(dat);
					gui.getCommandField().setText(gui.getUserCommand() + " " 
							+ task.getDetails() + datString);
					
					highlightText();
				}
			} catch (NumberFormatException e) {
				;//Do nothing if it is not number
			}
		}
	}

	private void highlightText() {
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				gui.getCommandField().select(
						gui.getUserCommand().length() + 1,
						gui.getCommandField().getText().length() - 1);
			}
		});
	}
	
	private String getDateTimeStringForEdit(TDTDateAndTime dat) {
		String datString = "";
		if (dat.isTimedTask()) {
			datString = " from";
			if (!dat.getStartDate().equals("null")) {
				datString = datString + " " + dat.getStartDate();
			}
			if (!dat.getStartTime().equals("null")) {
				datString = datString + " " + dat.getStartTime();
			}
			if (!dat.getEndDate().equals("null") || !dat.getEndTime().equals("null")) {
				datString = datString + " to";
				if (!dat.getEndDate().equals("null")) {
					datString = datString + " " + dat.getEndDate();
				}
				if (!dat.getEndTime().equals("null")) {
					datString = datString + " " + dat.getEndTime();
				}
			}
		}
		if (dat.isDeadlineTask()) {
			datString = " by";
			if (!dat.getEndDate().equals("null")) {
				datString = datString + " " + dat.getEndDate();
			}
			if (!dat.getEndTime().equals("null")) {
				datString = datString + " " + dat.getEndTime();
			}
		}
		return datString;
	}
	
	
	private void renewCommandField() {
		gui.setUserCommand(gui.getCommandField().getText());
		gui.getCommandHistory().add(gui.getUserCommand());
		gui.setHistoryPointer(gui.getCommandHistory().size());
		gui.getCommandField().setText("");
	}

	private void updateView(int scrollVal, String feedback) {
		int value = gui.getControl().getScrollVal();
		if(value != -1) {
			scrollVal = value;
		}
		if(gui.getControl().getViewMode() == TDTController.SEARCH_VIEW) {
			gui.updateGUI(feedback, gui.displaySearch(gui.getControl().getSearchedTask()));
			scrollTo(0);
		} else if(gui.getControl().getViewMode() == TDTController.HELP_VIEW) {
			gui.updateGUI("Displaying Help text.", feedback);
			scrollTo(0);
		} else {
			gui.updateGUI(feedback, gui.displayTask(gui.getControl().getHighlightTask(),
					gui.getControl().getAddedTask()));
			scrollTo(scrollVal * _SCROLLFACTOR);
		}
	}

	private void scrollTo(final int value) {
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				gui.getScrollPane().getVerticalScrollBar().setValue(value);
			}
		});
	}

	@Override
	public void keyReleased(KeyEvent arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void keyTyped(KeyEvent arg0) {
		// TODO Auto-generated method stub

	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\gui\TDTKeyListener.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\AddCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;
import java.util.Iterator;

import todothis.commons.TDTCommons;
import todothis.commons.TDTDateAndTime;
import todothis.commons.Task;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class AddCommand extends Command {
	private static final String MESSAGE_UNDO_ADD = "Undo add.";
	public static final String MESSAGE_INVALID_END_TIME = "Invalid end time! End Time should be after start time!";
	public static final String MESSAGE_INVALID_END_DATE = "Invalid end date! End date should be after start date!";
	public static final String MESSAGE_INVALID_DATE_TIME_FORMAT = "Invalid date/time format.";
	public static final String MESSAGE_ADD_FEEDBACK = "Task added to %s.";
	public static final String MESSAGE_ADD_CLASH = "Clashes detected. %s \n%d task(s) found to have same time range on %s";

	private int taskID;
	private String labelName;
	private String commandDetails;
	private TDTDateAndTime dateAndTime;
	private boolean isHighPriority;
	private ArrayList<Task> targetTask;
	private Task addedTask;
	private String feedback = "";
	private boolean gotClashes = false;
	
	/**
	 * Construct the AddCommand object.
	 * @param commandDetails
	 * @param dateAndTime
	 * @param isHighPriority
	 */
	public AddCommand(String commandDetails, TDTDateAndTime dateAndTime,
			boolean isHighPriority) {
		super(COMMANDTYPE.ADD);
		this.setHighPriority(isHighPriority);
		this.setCommandDetails(commandDetails);
		this.setDateAndTime(dateAndTime);
		this.setTargetTask(new ArrayList<Task>());
	}
	
	/**
	 * Create a Task object and add into the TDTdataStore 
	 */
	@Override
	public String execute(TDTDataStore data) {
		setLabelName(data.getCurrLabel());
		setTaskID(data.getLabelSize(getLabelName()) + 1);
		Task task = new Task(getTaskID(), labelName, getCommandDetails(),
				getDateAndTime(), isHighPriority());
		setAddedTask(task);
		TDTDateAndTime dnt = getDateAndTime();

		if (!TDTCommons.isValidDateTimeRange(dnt)) {
			return MESSAGE_INVALID_DATE_TIME_FORMAT;
		}

		if (!TDTCommons.isValidStartEndDate(dnt)) {
			return MESSAGE_INVALID_END_DATE;
		}

		if (!TDTCommons.isValidStartEndTime(dnt)) {
			return MESSAGE_INVALID_END_TIME;
		}

		checkForClash(task, data.getTaskIterator());
		data.addTask(task);
		setTaskID(TDTCommons.sort(data.getTaskMap().get(getLabelName()), task));
		data.insertToUndoStack(this);

		return gotClashes ? this.getFeedback() : String.format(
				MESSAGE_ADD_FEEDBACK, data.getCurrLabel());
	}

	private void checkForClash(Task target, Iterator<Task> iter) {
		int numClash = 0;
		while (iter.hasNext()) {
			Task task = iter.next();
			if (task != target && !task.isDone()) {
				if (target.getDateAndTime().isClash(task.getDateAndTime())) {
					targetTask.add(task);
					numClash++;
					gotClashes = true;
				}
			}
		}
		if (gotClashes) {
			String feedback = String.format(MESSAGE_ADD_CLASH,
					String.format(MESSAGE_ADD_FEEDBACK, target.getLabelName()),
					numClash, target.getDateAndTime().getStartDate());
			this.setFeedback(feedback);
		}
	}
	
	/**
	 * Reverses the effect of execute
	 */
	@Override
	public String undo(TDTDataStore data) {
		targetTask.clear();
		DeleteCommand comd = new DeleteCommand(getLabelName(), getTaskID());
		comd.execute(data);
		assert (data.getUndoStack().size() > 0) : "undostack is empty";
		data.getUndoStack().pop();
		return MESSAGE_UNDO_ADD;
	}

	public int getTaskID() {
		return taskID;
	}

	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}

	public String getCommandDetails() {
		return commandDetails;
	}

	public void setCommandDetails(String commandDetails) {
		this.commandDetails = commandDetails;
	}

	public TDTDateAndTime getDateAndTime() {
		return dateAndTime;
	}

	public void setDateAndTime(TDTDateAndTime dateAndTime) {
		this.dateAndTime = dateAndTime;
	}

	public boolean isHighPriority() {
		return isHighPriority;
	}

	public void setHighPriority(boolean isHighPriority) {
		this.isHighPriority = isHighPriority;
	}

	public ArrayList<Task> getTargetTask() {
		return targetTask;
	}

	public void setTargetTask(ArrayList<Task> targetTask) {
		this.targetTask = targetTask;
	}

	public String getFeedback() {
		return feedback;
	}

	public void setFeedback(String feedback) {
		this.feedback = feedback;
	}

	public Task getAddedTask() {
		return addedTask;
	}

	public void setAddedTask(Task addedTask) {
		this.addedTask = addedTask;
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\AddCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\Command.java
	 */

package todothis.logic.command;

import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;


public abstract class Command {
	private COMMANDTYPE commandType;
	
	public Command(COMMANDTYPE commandType) {
		this.commandType = commandType;
	}
	
	public abstract String execute(TDTDataStore data);
	public abstract String undo(TDTDataStore data);
	
	public COMMANDTYPE getCommandType() {
		return this.commandType;
	}
}


	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\Command.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\DeleteCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import todothis.commons.TDTCommons;
import todothis.commons.Task;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class DeleteCommand extends Command {
	public static final String MESSAGE_UNDO_DELETE_TASK = "Undo delete task.";
	public static final String MESSAGE_DELETE_TASK = "Task deleted";
	public static final String MESSAGE_INVALID = "Invalid command.";
	public static final String MESSAGE_INVALID_LABEL_TASKID = "Invalid command. Label does not exist or invalid task number.";
	public static final String MESSAGE_DELETE_LABEL = "Label deleted.";
	public static final String MESSAGE_UNDO_CLEAR = "Undo clear TodoThis.";
	public static final String MESSAGE_CLEAR = "TodoThis is cleared!";
	public static final String MESSAGE_DELETE_LABEL_TASK = "Task under %s deleted.";
	public static final String MESSAGE_UNDO_DELETE_LABEL_TASK = "Undo delete %s.";
	private static final int DELETE_ALL = 0;
	private static final int DELETE_LABELTASK = 1;
	private static final int DELETE_LABEL = 2;
	private static final int DELETE_TASK = 3;
	
	private int deleteState = -1;
	private int taskID;
	private String labelName;
	private HashMap<String, ArrayList<Task>> prevState;
	private String prevLabelPointer;
	private ArrayList<RemindCommand> undoReminderList = new ArrayList<RemindCommand>();
	private ArrayList<Task> undoTaskList = new ArrayList<Task>();

	private String undoLabel;
	private String undoFeedback = "";
	
	/**
	 * Construct a DeleteCommand object. 
	 * @param labelName
	 * @param taskID
	 */
	public DeleteCommand(String labelName, int taskID) {
		super(COMMANDTYPE.DELETE);
		this.setTaskID(taskID);
		this.setLabelName(labelName.toUpperCase());
	}
	
	/**
	 * Delete all the task if labelName is blank and taskID = -1
	 * Delete all the task under a label if taskID = -1
	 * Delete label if taskID = -1 and no task under that label
	 * Delete task from current label if taskID != -1 and label is blank
	 * Delete task from specific label if taskID != -1 and label is not blank
	 */
	@Override
	public String execute(TDTDataStore data) {
		prevLabelPointer = data.getCurrLabel();
		String label = getLabelName();
		int taskId = getTaskID();
		
		//delete
		if(label.equals("") && taskId == -1) {
			deleteEverything(data);
			return MESSAGE_CLEAR;
		}
		
		//delete label
		if(!label.equals("") && taskId == -1) {
			if(data.getTaskMap().containsKey(label)) {
				//If label is empty, delete label
				if(data.getLabelSize(label) == 0) {
					deleteLabel(data, label);
					return MESSAGE_DELETE_LABEL;
				} else {
					//label not empty, clear task in label
					deleteLabelTask(data, label);
					return String.format(MESSAGE_DELETE_LABEL_TASK, label);
				}
			} else {
				return MESSAGE_INVALID_LABEL_TASKID;
			}
		}
		
		//delete task from current label
		if(label.equals("") && taskId != -1) {
			ArrayList<Task> array = data.getTaskMap().get(data.getCurrLabel());
			if(taskId <= array.size() && getTaskID() > 0) {
				deleteTask(data.getCurrLabel(),taskId, data);
				return MESSAGE_DELETE_TASK;
			} else {
				return MESSAGE_INVALID_LABEL_TASKID;
			}
		}
		
		//delete task from specific label
		if(!label.equals("") && taskId != -1) {
			if(data.getTaskMap().containsKey(label)) {
				ArrayList<Task> array = data.getTaskMap().get(label);
				if(taskId <= array.size() && getTaskID() > 0) {
					deleteTask(label,taskId, data);
					return MESSAGE_DELETE_TASK;
				} else {
					return MESSAGE_INVALID_LABEL_TASKID;
				}
			} else {
				return MESSAGE_INVALID_LABEL_TASKID;
			}
		}
		
		return MESSAGE_INVALID;
	}

	private void deleteTask(String label, int taskId, TDTDataStore data) {
		setDeleteState(DELETE_TASK);
		undoLabel = label;
		ArrayList<Task> taskList = data.getTaskListFromLabel(label);
		undoTaskList = copyTaskList(taskList);
		Task task = taskList.get(taskId - 1);
		if(task.hasReminder()) {
			task.getReminder().cancelReminder();
			undoReminderList.add(new RemindCommand(task.getLabelName(), task.getTaskID(), 
						task.getRemindDateTime()));
		}
		taskList.remove(taskId - 1);
		TDTCommons.renumberTaskID(taskList, null);
		data.insertToUndoStack(this);
		setUndoFeedback(MESSAGE_UNDO_DELETE_TASK);
	}

	
	private void deleteEverything(TDTDataStore data) {
		prevState = copyLabelMap(data);
		setDeleteState(DELETE_ALL);
		Iterator<String> iter = data.getLabelIterator();
		while(iter.hasNext()) {
			String next = iter.next();
			ArrayList<Task> taskList = data.getTaskMap().get(next);
			stopReminderInTaskList(taskList);
		}
		
		data.setTaskMap(new HashMap<String, ArrayList<Task>>());
		data.getTaskMap().put(TDTCommons.DEFAULT_LABEL, new ArrayList<Task>());
		data.setCurrLabel(TDTCommons.DEFAULT_LABEL);
		data.insertToUndoStack(this);
		setUndoFeedback(MESSAGE_UNDO_CLEAR);
	}
	

	private void deleteLabel(TDTDataStore data, String label) {
		undoLabel = label;
		setDeleteState(DELETE_LABEL);
		data.getTaskMap().remove(label);
		data.getAutoWords().remove(label);
		data.setCurrLabel(TDTCommons.DEFAULT_LABEL);
		if(label.equals(TDTCommons.DEFAULT_LABEL)) {
			data.getTaskMap().put(TDTCommons.DEFAULT_LABEL, new ArrayList<Task>());
			data.insertToAutoWords(TDTCommons.DEFAULT_LABEL);
		}
		data.insertToUndoStack(this);
		setUndoFeedback(String.format(MESSAGE_UNDO_DELETE_LABEL_TASK, label));
	}
	
	private void deleteLabelTask(TDTDataStore data, String label) {
		undoLabel = label;
		ArrayList<Task> taskList = data.getTaskListFromLabel(label);
		undoTaskList = copyTaskList(taskList);
		setDeleteState(DELETE_LABELTASK);
		stopReminderInTaskList(taskList);
		taskList.clear();
		data.insertToUndoStack(this);
		setUndoFeedback(String.format(MESSAGE_UNDO_DELETE_LABEL_TASK, label));
	}
	
	private void stopReminderInTaskList(ArrayList<Task> array) {
		Iterator<Task> iter = array.iterator();
		while(iter.hasNext()) {
			Task task = iter.next();
			if(task.hasReminder()) {
				task.getReminder().cancelReminder();
				undoReminderList.add(new RemindCommand(task.getLabelName(), task.getTaskID(), 
						task.getRemindDateTime()));
			}
		}
	}
	
	/**
	 * Reverses the effect of execute.
	 */
	@Override
	public String undo(TDTDataStore data) {
		data.setCurrLabel(prevLabelPointer);
		if(getDeleteState() == DELETE_ALL) {
			undoDeleteAll(data);
		}
		
		if(getDeleteState() == DELETE_LABEL) {
			undoDeleteLabel(data);
		}
		
		if(getDeleteState() == DELETE_LABELTASK) {
			undoDeleteLabelTask(data);
		}
		
		if(getDeleteState() == DELETE_TASK) {
			undoDeleteTask(data);
		}

		return getUndoFeedback();
	}
	
	private void undoDeleteTask(TDTDataStore data) {
		data.getTaskMap().put(undoLabel, undoTaskList);
		restartReminder(data);
	}

	private void undoDeleteLabelTask(TDTDataStore data) {
		data.getTaskMap().put(undoLabel, undoTaskList);
		restartReminder(data);
	}

	private void undoDeleteLabel(TDTDataStore data) {
		data.getTaskMap().put(undoLabel, new ArrayList<Task>());
		data.setCurrLabel(prevLabelPointer);
	}

	private void undoDeleteAll(TDTDataStore data) {
		data.setTaskMap(prevState);
		restartReminder(data);
	}
	
	private void restartReminder(TDTDataStore data) {
		for(int i = 0; i < undoReminderList.size(); i++) {
			undoReminderList.get(i).execute(data);
			assert(data.getUndoStack().size() > 0);
			data.getUndoStack().pop();
		}
		undoReminderList.clear();
	}
	
	private HashMap<String, ArrayList<Task>> copyLabelMap(TDTDataStore data) {
		HashMap<String, ArrayList<Task>> hmap = new HashMap<String, ArrayList<Task>>();
		Iterator<String> labelIter = data.getLabelIterator();
		Iterator<Task> taskIter = data.getTaskIterator();
		
		while(labelIter.hasNext()) {
			String next = labelIter.next();
			hmap.put(next, new ArrayList<Task>());
		}
		while(taskIter.hasNext()) {
			Task task =  taskIter.next();
			hmap.get(task.getLabelName()).add(new Task(task.getTaskID(), task.getLabelName(),
					 task.getDetails(), task.getDateAndTime(), task.isHighPriority(), 
					 task.isDone(), "null"));
		}
		return hmap;
	}
	
	private ArrayList<Task> copyTaskList(ArrayList<Task> array) {
		ArrayList<Task> res = new ArrayList<Task>();
		Iterator<Task> taskIter = array.iterator();
		while(taskIter.hasNext()) {
			Task task =  taskIter.next();
			res.add(new Task(task.getTaskID(), task.getLabelName(),
					 task.getDetails(), task.getDateAndTime(), task.isHighPriority(), 
					 task.isDone(), "null"));
		}
		return res;
	}
	
	/*
	@Override
	public String execute(TDTDataStore data) {
		prevState = data.copyLabelMap();
		prevLabelPointer = data.getCurrLabel();
		String label = getLabelName().toUpperCase();
		int taskId = getTaskID();
		
		data.insertToUndoStack(this);
		//delete
		if(label.equals("") && taskId == -1) {
			deleteEverything(data);
			
			setUndoFeedback("Undo delete");
			return data.getFileName() + " is cleared!";
		}
		
		//delete label
		if(!label.equals("") && taskId == -1) {
			if(data.getLabelMap().containsKey(label)) {
				//If label is empty, delete label
				if(data.getLabelSize(label) == 0) {
					deleteLabel(data, label);
					
					setUndoFeedback("Undo delete " + label);
					return "Label deleted.";
				} else {
					//label not empty, clear task in label
					data.getLabelMap().get(label).clear();
				}
			} else {
				return "Invalid command. Label does not exist.";
			}
		}
		
		//delete task from current label
		if(label.equals("") && taskId != -1) {
			ArrayList<Task> array = data.getLabelMap().get(data.getCurrLabel());
			if(taskId <= array.size() && getTaskID() > 0) {
				array.remove(taskId - 1);
				TDTLogic.renumberTaskID(array, null);
				
				return "Task deleted";
			} else {
				return "Invalid command. Invalid task number.";
			}
		}
		
		//delete task from specific label
		if(!label.equals("") && taskId != -1) {
			if(data.getLabelMap().containsKey(label)) {
				ArrayList<Task> array = data.getLabelMap().get(label);
				if(taskId <= array.size() && getTaskID() > 0) {
					array.remove(taskId - 1);
					TDTLogic.renumberTaskID(array, null);
					return "Task deleted";
				} else {
					return "Invalid command. Invalid task number.";
				}
			} else {
				return "Invalid command. Label does not exist.";
			}
		}
		//Shouldnt reach here
		return "Invalid command.";
	}

	@Override
	public String undo(TDTDataStore data) {
		//May not undo the reminders.
		//Delete may not off the reminders.
		//Suggest
		//Delete all go thru each task to off reminders
		//Undo go thru each task to add back reminder
		data.setLabelMap(prevState);
		data.setCurrLabel(prevLabelPointer);
		return getUndoFeedback();
	}*/
	
	
	
	//------------------------------GETTERS & SETTERS -------------------------------
	
	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}

	public int getTaskID() {
		return taskID;
	}

	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}

	public String getUndoFeedback() {
		return undoFeedback;
	}

	public void setUndoFeedback(String undoFeedback) {
		this.undoFeedback = undoFeedback;
	}

	public int getDeleteState() {
		return deleteState;
	}

	public void setDeleteState(int deleteState) {
		this.deleteState = deleteState;
	}

	

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\DeleteCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\DoneCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;
import java.util.Iterator;

import todothis.commons.Task;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class DoneCommand extends Command {
	public static final String MESSAGE_DONE_TASK_FEEDBACK = "Task done";
	public static final String MESSAGE_UNDO_DONE = "Undo done";
	public static final String MESSAGE_INVALID_COMMAND = "Invalid command.";
	public static final String MESAGE_INVALID_LABEL_TASKID = "Invalid Command. Label does not exist or invalid task number.";
	public static final String MESSAGE_DONE_ALL_FEEDBACK = "All tasks are done!";
	public static final String MESSAGE_DONE_LABEL_FEEDBACK = "Tasks under %s are done.";

	private int taskID;
	private String labelName;
	private boolean isDone = true;

	/**
	 * Construct a DoneCommand object
	 * 
	 * @param labelName
	 * @param taskID
	 */
	public DoneCommand(String labelName, int taskID) {
		super(COMMANDTYPE.DONE);
		this.setTaskID(taskID);
		this.setLabelName(labelName.toUpperCase());
	}

	/**
	 * Mark all the task as done if labelName is blank and taskID = -1 Mark all
	 * the task as done under a label if taskID = -1 Mark task from current
	 * label as done if taskID != -1 and label is blank Mark task from specific
	 * label as done if taskID != -1 and label is not blank
	 */
	@Override
	public String execute(TDTDataStore data) {
		String label = getLabelName().toUpperCase();
		int taskId = getTaskID();

		// done
		if (label.equals("") && taskId == -1) {
			Iterator<Task> iter = data.getTaskIterator();
			while (iter.hasNext()) {
				Task next = iter.next();
				next.setDone(isDone);
			}

			data.insertToUndoStack(this);
			return MESSAGE_DONE_ALL_FEEDBACK;
		}

		// done label
		if (!label.equals("") && taskId == -1) {
			if (data.getTaskMap().containsKey(label)) {
				ArrayList<Task> array = data.getTaskMap().get(label);
				for (int i = 0; i < array.size(); i++) {
					Task task = array.get(i);
					task.setDone(isDone);
				}

				data.insertToUndoStack(this);
				return MESSAGE_DONE_LABEL_FEEDBACK;
			} else {
				return MESAGE_INVALID_LABEL_TASKID;
			}
		}

		// done task from current label
		if (label.equals("") && taskId != -1) {
			ArrayList<Task> array = data.getTaskMap().get(data.getCurrLabel());
			if (taskId <= array.size() && getTaskID() > 0) {
				Task task = array.get(taskId - 1);
				task.setDone(isDone);

				data.insertToUndoStack(this);
				return MESSAGE_DONE_TASK_FEEDBACK;
			} else {
				return MESAGE_INVALID_LABEL_TASKID;
			}
		}

		// delete task from specific label
		if (!label.equals("") && taskId != -1) {
			if (data.getTaskMap().containsKey(label)) {
				ArrayList<Task> array = data.getTaskMap().get(label);
				if (taskId <= array.size() && getTaskID() > 0) {
					Task task = array.get(taskId - 1);
					task.setDone(isDone);

					data.insertToUndoStack(this);
					return MESSAGE_DONE_TASK_FEEDBACK;
				} else {
					return MESAGE_INVALID_LABEL_TASKID;
				}
			} else {
				return MESAGE_INVALID_LABEL_TASKID;
			}
		}
		// Shouldnt reach here
		return MESSAGE_INVALID_COMMAND;
	}

	/**
	 * Reverses the effect of execute.
	 */
	@Override
	public String undo(TDTDataStore data) {
		DoneCommand comd = new DoneCommand(getLabelName(), getTaskID());
		comd.setDone(false);
		comd.execute(data);
		assert (data.getUndoStack().size() > 0) : "undostack is empty";
		data.getUndoStack().pop();
		return MESSAGE_UNDO_DONE;
	}

	public int getTaskID() {
		return taskID;
	}

	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}

	public boolean isDone() {
		return isDone;
	}

	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\DoneCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\EditCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;
import java.util.Iterator;

import todothis.commons.TDTCommons;
import todothis.commons.TDTDateAndTime;
import todothis.commons.Task;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class EditCommand extends Command {
	public static final String MESSAGE_UNDO_EDIT = "Undo edit";
	public static final String MESSAGE_INVALID_COMMAND = "Invalid Command";
	public static final String MESSAGE_INVALID_LABEL_TASKID = "Invalid Command. Label does not exist or invalid task number.";
	public static final String MESSAGE_INVALID_END_TIME = "Invalid end time! End Time should be after start time!";
	public static final String MESSAGE_INVALID_END_DATE = "Invalid end date! End date should be after start date!";
	public static final String MESSAGE_INVALID_DATE_TIME_FORMAT = "Invalid date/time format.";
	public static final String MESSAGE_EDIT_FEEDBACK = "Task edited.";
	public static final String MESSAGE_EDIT_CLASH = "Clashes detected. Task edited.\n%d task(s) found to have same time range on %s";

	private int taskID;
	private String feedback;
	private String labelName;
	private String commandDetails;
	private TDTDateAndTime dateAndTime;
	private boolean isHighPriority;
	private String prevDetails;
	private TDTDateAndTime prevDNT;
	private boolean prevPriority;
	private Task editedTask;
	private boolean gotClashes = false;
	private ArrayList<Task> targetTask;
	
	/**
	 * Construct a EditCommand object
	 * 
	 * @param labelName
	 * @param taskID
	 * @param commandDetails
	 * @param dateAndTime
	 * @param isHighPriority
	 */
	public EditCommand(String labelName, int taskID, String commandDetails,
			TDTDateAndTime dateAndTime, boolean isHighPriority) {
		super(COMMANDTYPE.EDIT);
		this.setTaskID(taskID);
		this.setHighPriority(isHighPriority);
		this.setLabelName(labelName.toUpperCase());
		this.setCommandDetails(commandDetails);
		this.setDateAndTime(dateAndTime);
		this.setTargetTask(new ArrayList<Task>());
	}
	
	/**
	 * Edit a task from current label or a specific label.
	 */
	@Override
	public String execute(TDTDataStore data) {
		String label = getLabelName().toUpperCase();
		int taskId = getTaskID();
		String commandDetails = getCommandDetails();
		boolean isHighPriority = isHighPriority();
		TDTDateAndTime dateAndTime = getDateAndTime();

		// edit task from current label
		if (label.equals("") && taskId != -1) {
			setLabelName(data.getCurrLabel());
			ArrayList<Task> array = data.getTaskMap().get(getLabelName());
			if (taskId <= array.size() && getTaskID() > 0) {
				Task task = array.get(taskId - 1);
				return editTask(data, commandDetails, isHighPriority,
						dateAndTime, task);
			} else {
				return MESSAGE_INVALID_LABEL_TASKID;
			}
		}

		// edit task from specific label
		if (!label.equals("") && taskId != -1) {
			if (data.getTaskMap().containsKey(label)) {
				ArrayList<Task> array = data.getTaskMap().get(label);
				if (taskId <= array.size() && getTaskID() > 0) {
					Task task = array.get(taskId - 1);
					return editTask(data, commandDetails, isHighPriority,
							dateAndTime, task);
				} else {
					return MESSAGE_INVALID_LABEL_TASKID;
				}
			} else {
				return MESSAGE_INVALID_LABEL_TASKID;
			}
		}

		return MESSAGE_INVALID_COMMAND;
	}

	private String editTask(TDTDataStore data, String commandDetails,
			boolean isHighPriority, TDTDateAndTime dateAndTime, Task task) {
		if (!TDTCommons.isValidDateTimeRange(dateAndTime)) {
			return MESSAGE_INVALID_DATE_TIME_FORMAT;
		}

		if (!TDTCommons.isValidStartEndDate(dateAndTime)) {
			return MESSAGE_INVALID_END_DATE;
		}

		if (!TDTCommons.isValidStartEndTime(dateAndTime)) {
			return MESSAGE_INVALID_END_TIME;
		}
		setEditDetails(commandDetails, isHighPriority, dateAndTime, task);
		checkForClash(task, data.getTaskIterator());
		data.insertToUndoStack(this);
		return gotClashes ? this.getFeedback() : MESSAGE_EDIT_FEEDBACK;
	}

	private void checkForClash(Task target, Iterator<Task> iter) {
		int numClash = 0;
		while (iter.hasNext()) {
			Task task = iter.next();
			if (task != target && !task.isDone()) {
				if (target.getDateAndTime().isClash(task.getDateAndTime())) {
					targetTask.add(task);
					numClash++;
					gotClashes = true;
				}
			}
		}
		if (gotClashes) {
			String feedback = String.format(MESSAGE_EDIT_CLASH, numClash,
					target.getDateAndTime().getStartDate());

			this.setFeedback(feedback);
		}
	}

	private void setEditDetails(String commandDetails, boolean isHighPriority,
			TDTDateAndTime dateAndTime, Task task) {
		setEditedTask(task);
		prevDetails = task.getDetails();
		prevDNT = task.getDateAndTime();
		prevPriority = task.isHighPriority();
		task.setDetails(commandDetails);
		task.setDateAndTime(dateAndTime);
		task.setHighPriority(isHighPriority);
	}
	
	/**
	 * Reverses the effect of execute.
	 */
	@Override
	public String undo(TDTDataStore data) {
		targetTask.clear();
		EditCommand comd = new EditCommand(getLabelName(), getTaskID(),
				prevDetails, prevDNT, prevPriority);
		comd.execute(data);
		assert (data.getUndoStack().size() > 0) : "undostack is empty";
		data.getUndoStack().pop();
		return MESSAGE_UNDO_EDIT;
	}

	public int getTaskID() {
		return taskID;
	}

	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}

	public String getCommandDetails() {
		return commandDetails;
	}

	public void setCommandDetails(String commandDetails) {
		this.commandDetails = commandDetails;
	}

	public TDTDateAndTime getDateAndTime() {
		return dateAndTime;
	}

	public void setDateAndTime(TDTDateAndTime dateAndTime) {
		this.dateAndTime = dateAndTime;
	}

	public boolean isHighPriority() {
		return isHighPriority;
	}

	public void setHighPriority(boolean isHighPriority) {
		this.isHighPriority = isHighPriority;
	}

	public Task getEditedTask() {
		return editedTask;
	}

	public void setEditedTask(Task editedTask) {
		this.editedTask = editedTask;
	}

	public ArrayList<Task> getTargetTask() {
		return targetTask;
	}

	public void setTargetTask(ArrayList<Task> targetTask) {
		this.targetTask = targetTask;
	}

	public String getFeedback() {
		return feedback;
	}

	public void setFeedback(String feedback) {
		this.feedback = feedback;
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\EditCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\ExitCommand.java
	 */

package todothis.logic.command;

import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class ExitCommand extends Command {

	/**
	 * Constructor for ExitCommand
	 */
	public ExitCommand() {
		super(COMMANDTYPE.EXIT);
	}

	/**
	 * Executing ExitCommand will exit TodoThis
	 */
	@Override
	public String execute(TDTDataStore data) {
		System.exit(0);
		return "";
	}

	@Override
	public String undo(TDTDataStore data) {
		return "";
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\ExitCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\HideCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;
import java.util.Iterator;

import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class HideCommand extends Command {
	public static final String MESSAGE_UNDO_HIDE = "Undo hide";
	public static final String MESSAGE_HIDE_FEEDBACK = "Hide selected labels.";
	
	private String labelName;
	private ArrayList<String> prevHideList;
	
	/**
	 * Construct a HideCommand
	 * @param labelName
	 */
	public HideCommand(String labelName) {
		super(COMMANDTYPE.HIDE);
		this.setLabelName(labelName.toUpperCase());
	}
	
	/**
	 * Hides a label from view.
	 */
	@Override
	public String execute(TDTDataStore data) {
		prevHideList = copyHideList(data.getHideList());
		String[] labelNames = getLabelName().split(" ");
		Iterator<String> iter = data.getLabelIterator();

		if(labelNames[0].equals("")){
			while(iter.hasNext()){
				String temp = iter.next();
				data.insertToHideList(temp);
			}
		}else {
			while(iter.hasNext()){
				String temp = iter.next();
				if(containInArray(temp, labelNames)){
					data.insertToHideList(temp);
				}
			}
		}
		
		data.insertToUndoStack(this);
		return MESSAGE_HIDE_FEEDBACK;
	}
	
	/**
	 * Reverses the effect of execute
	 */
	@Override
	public String undo(TDTDataStore data) {
		data.setHideList(prevHideList);
		return MESSAGE_UNDO_HIDE;
	}
	
	private ArrayList<String> copyHideList(ArrayList<String> hideList) {
		ArrayList<String> list = new ArrayList<String>();
		for(int i = 0 ; i < hideList.size(); i++) {
			list.add(hideList.get(i));
		}
		return list;
	}
	
	private static boolean containInArray(String label, String[] labelNames) {
		for(int i = 0; i < labelNames.length; i++) {
			if(labelNames[i].toUpperCase().equals(label)) {
				return true;
			}
		}
		return false;
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}
	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\HideCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\LabelCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;

import todothis.commons.Task;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class LabelCommand extends Command {
	public static final String MESSAGE_INVALID_ADD_LABEL = "Invalid command. Label name cannot be blank or digits only.";
	public static final String MESSAGE_INVALID_LABEL = "Invalid command. Invalid Label name.";
	public static final String MESSAGE_LABEL_FEEDBACK = "Current label change to: %s";
	public static final String MESSAGE_CREATE_LABEL_FEEDBACK = "Label %s created.";
	public static final String MESSAGE_UNDO_LABEL_FEEDBACK = "Label %s deleted.";
	
	private String labelName;
	private String prevLabel;
	private String undoFeedback;
	private boolean newLabelCreated = false;
	
	/**
	 * Construct a LabelCommand
	 * @param labelName
	 */
	public LabelCommand(String labelName) {
		super(COMMANDTYPE.LABEL);
		this.setLabelName(labelName);
	}

	/**
	 * Change the directory of current label or create a new label.
	 */
	@Override
	public String execute(TDTDataStore data) {
		prevLabel = data.getCurrLabel();
		String[] label = getLabelName().toUpperCase().split(" ");
		
		if(label.length > 1 || label.length <= 0) {
			return MESSAGE_INVALID_LABEL;
		}
		
		if(data.getTaskMap().containsKey(label[0])) {
			changeLabelDirectory(data, label);
			return String.format(MESSAGE_LABEL_FEEDBACK, label[0]);
		} else if(label[0].equals("") || label[0].matches("\\d+")) {
			return MESSAGE_INVALID_ADD_LABEL;
		} else {
			createNewLabel(data, label);
			return String.format(MESSAGE_CREATE_LABEL_FEEDBACK, label[0]);
		}
	}

	private void createNewLabel(TDTDataStore data, String[] label) {
		data.getTaskMap().put(label[0], new ArrayList<Task>());
		data.insertToAutoWords(label[0]);
		data.setCurrLabel(label[0]);
		newLabelCreated = true;
		setUndoFeedback(String.format(MESSAGE_UNDO_LABEL_FEEDBACK, label[0]));
		data.insertToUndoStack(this);
	}

	private void changeLabelDirectory(TDTDataStore data, String[] label) {
		data.setCurrLabel(label[0]);
		data.getHideList().remove(label[0]);
		setUndoFeedback(String.format(MESSAGE_LABEL_FEEDBACK, prevLabel));
		data.insertToUndoStack(this);
	}
	
	/**
	 * Reverses the effect of execute.
	 */
	@Override
	public String undo(TDTDataStore data) {
		data.setCurrLabel(prevLabel);
		if(newLabelCreated) {
			DeleteCommand comd = new DeleteCommand(labelName, -1);
			comd.execute(data);
			assert (data.getUndoStack().size() > 0) : "undostack is empty";
			data.getUndoStack().pop();
		}
		return getUndoFeedback();
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}

	public String getUndoFeedback() {
		return undoFeedback;
	}

	public void setUndoFeedback(String undoFeedback) {
		this.undoFeedback = undoFeedback;
	}

	

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\LabelCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\RedoCommand.java
	 */

package todothis.logic.command;

import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class RedoCommand extends Command{
	private Command comd;
	public static final String MESSAGE_INVALID_REDO = "Invalid command. No command to redo.";

	public RedoCommand() {
		super(COMMANDTYPE.REDO);
	}
	
	/**
	 * Pop the previous command from redoStack and execute.
	 */
	@Override
	public String execute(TDTDataStore data) {
		if(!data.getRedoStack().isEmpty()) {
			setComd(data.getRedoStack().pop());
			return comd.execute(data);
		} else {
			return MESSAGE_INVALID_REDO;
		}
	}

	@Override
	public String undo(TDTDataStore data) {
		return null;
	}

	public Command getComd() {
		return comd;
	}

	public void setComd(Command comd) {
		this.comd = comd;
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\RedoCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\RemindCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;

import todothis.commons.TDTReminder;
import todothis.commons.TDTTimeMethods;
import todothis.commons.Task;
import todothis.logic.parser.TDTDateAndTimeParser;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class RemindCommand extends Command {
	public static final String MESSAGE_UNDO_REMOVE_REMIND = "Undo remove reminder.";
	public static final String MESSAGE_UNDO_REMIND = "Undo reminder.";
	public static final String MESSAGE_INVALID_REMOVE_REMIND = "Invalid command. No reminder to remove.";
	public static final String MESSAGE_INVALID_LABEL = "Invalid command. Invalid label name.";
	public static final String MESSAGE_INVALID_TASKID = "Invalid command. Invalid taskId.";
	public static final String MESSAGE_INVALID_REMIND = "Invalid command. Invalid date/time for reminder.";
	public static final String MESSAGE_REMIND_FEEDBACK = "Reminder set at %s";
	public static final String MESSAGE__REMOVE_REMIND_FEEDBACK = "Reminder at %s removed.";

	private String labelName;
	private int taskID;
	private String commandDetails;
	private Task task;
	private boolean isRemoveReminder = false;
	private String prevReminder;
	
	/**
	 * Construct a RemindCommand object
	 * 
	 * @param labelName
	 * @param taskId
	 * @param commandDetails
	 */
	public RemindCommand(String labelName, int taskId, String commandDetails) {
		super(COMMANDTYPE.REMIND);
		this.setLabelName(labelName.toUpperCase());
		this.setTaskID(taskId);
		this.setCommandDetails(commandDetails);
	}
	
	/**
	 * Set/Update/Remove reminder on a specific task from current label or a specific label.
	 */
	@Override
	public String execute(TDTDataStore data) {
		if (labelName.equalsIgnoreCase("")) {
			setLabelName(data.getCurrLabel());
		}

		if (getCommandDetails().equals("")) {
			isRemoveReminder = true;
			return removeReminder(data);
		}
		if (data.getTaskMap().containsKey(getLabelName())) {
			ArrayList<Task> array = data.getTaskMap().get(getLabelName());
			if (getTaskID() > 0 && getTaskID() <= array.size()) {
				Task temp = array.get(getTaskID() - 1);
				String remindDateTime = TDTDateAndTimeParser
						.decodeReminderDetails(getCommandDetails());
				if (!remindDateTime.equals("null")) {
					setReminderForTask(data, temp, remindDateTime);
					return String.format(MESSAGE_REMIND_FEEDBACK,
							remindDateTime);
				} else {
					return MESSAGE_INVALID_REMIND;
				}
			} else {
				return MESSAGE_INVALID_TASKID;
			}
		} else {
			return MESSAGE_INVALID_LABEL;
		}
	}

	private void setReminderForTask(TDTDataStore data, Task temp, String remindDateTime) {
		temp.setRemindDateTime(remindDateTime);
		temp.setReminder(new TDTReminder(TDTTimeMethods
				.calculateRemainingTime(remindDateTime), temp));
		setTask(temp);
		data.insertToUndoStack(this);
	}

	private String removeReminder(TDTDataStore data) {
		if (data.getTaskMap().containsKey(getLabelName())) {
			ArrayList<Task> array = data.getTaskMap().get(getLabelName());
			if (getTaskID() > 0 && getTaskID() <= array.size()) {
				Task temp = array.get(getTaskID() - 1);
				if (temp.getReminder() == null) {
					return MESSAGE_INVALID_REMOVE_REMIND;
				}
				String dateTime = temp.getRemindDateTime();
				prevReminder = dateTime;
				setTask(temp);
				temp.getReminder().cancelReminder();
				temp.setReminder(null);
				temp.setRemindDateTime("null");
				data.insertToUndoStack(this);
				return String.format(MESSAGE__REMOVE_REMIND_FEEDBACK, dateTime);
			} else {
				return MESSAGE_INVALID_TASKID;
			}
		} else {
			return MESSAGE_INVALID_LABEL;
		}
	}
	
	/**
	 * Reverses the effect of execute.
	 */
	@Override
	public String undo(TDTDataStore data) {
		if (!isRemoveReminder) {
			Task temp = getTask();
			if (temp.getReminder() != null) {
				temp.getReminder().cancelReminder();
				temp.setReminder(null);
				temp.setRemindDateTime("null");
			}
			return MESSAGE_UNDO_REMIND;
		} else {
			Task temp = getTask();
			temp.setRemindDateTime(prevReminder);
			temp.setReminder(new TDTReminder(TDTTimeMethods
					.calculateRemainingTime(prevReminder), temp));
			return MESSAGE_UNDO_REMOVE_REMIND;
		}
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}

	public int getTaskID() {
		return taskID;
	}

	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}

	public String getCommandDetails() {
		return commandDetails;
	}

	public void setCommandDetails(String commandDetails) {
		this.commandDetails = commandDetails;
	}

	public Task getTask() {
		return task;
	}

	public void setTask(Task task) {
		this.task = task;
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\RemindCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\SearchCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;
import java.util.Iterator;

import todothis.commons.TDTDateAndTime;
import todothis.commons.Task;
import todothis.logic.parser.TDTDateAndTimeParser;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class SearchCommand extends Command {
	public static final String MESSAGE_UNDO_SEARCH = "Undo Search";
	public static final String SEARCH_FEEDBACK = "%d results found.";
	
	private String searchedWords;
	private ArrayList<Task> searchedResult;
	private String searchDate;

	/**
	 * Constructor for SearchCommand. Able to search by done, overdue, keywords, date.
	 * @param searchedWords
	 */
	public SearchCommand(String searchedWords) {
		super(COMMANDTYPE.SEARCH);
		this.setSearchedWords(searchedWords.trim());
		this.setSearchedResult(new ArrayList<Task>());
		this.setSearchDate("");
	}
	
	/**
	 * Execute the search command, returning the number of results found and storing
	 * the searched tasks in a ArrayList.
	 */
	@Override
	public String execute(TDTDataStore data) {
		Iterator<Task> iter = data.getTaskIterator();
		if(searchedWords.equals("")) {
			searchEveryTask(iter);
		} else if(searchedWords.trim().equalsIgnoreCase("done") ){
			searchDoneTask(iter);
		} else if(searchedWords.trim().equalsIgnoreCase("overdue") ){
			searchOverdueTask(iter);
		} else {
			this.setSearchedWords(getSearchedWords().replaceAll("\"", ""));
			if(searchedWords.indexOf('@') != -1) {
				this.setSearchDate(TDTDateAndTimeParser.decodeSearchDetails(
						searchedWords.substring(searchedWords.indexOf('@') + 1)));
				this.setSearchedWords(searchedWords.substring(0, searchedWords.indexOf('@')));
				
				searchKeyWords(iter);
				searchByDate(searchedResult.iterator());
			} else {
				searchKeyWords(iter);
			}
		}
		data.insertToUndoStack(this);
		return String.format(SEARCH_FEEDBACK, searchedResult.size());	
	}
	
	/**
	 * Undo method for search. Undoing search will just return to the main screen.
	 */
	@Override
	public String undo(TDTDataStore data) {
		searchedResult.clear();
		return MESSAGE_UNDO_SEARCH;
	}
	
	//-------------------------------Private methods---------------------------------------
	
	//Search the task list by dates. If either the start or end dates matches the search,
	//the task is added to the search result.
	private void searchByDate(Iterator<Task> iter) {
		String[] params = this.getSearchDate().split(" ");
		ArrayList<Task> newSearchResult = new ArrayList<Task>();
		while(iter.hasNext()) {
			Task task = iter.next();
			String startDate = task.getDateAndTime().getStartDate();
			String endDate = task.getDateAndTime().getEndDate();
			
			for(int i = 0; i < params.length; i++) {
				if(params[i].equals(startDate) || params[i].equals(endDate)) {
					if(!newSearchResult.contains(task)) {
						newSearchResult.add(task);
					}
				}
			}
		}
		this.setSearchedResult(newSearchResult);
	}
	
	//Search the task list by keywords. If the task details matches ALL the key words,
	//the task is added to search result. The more key words the user specify, the 
	//narrow the search result will be.
	private void searchKeyWords(Iterator<Task> iter) {
		boolean found = false;
		String[] keyWords = searchedWords.split(" ");
		
		while(iter.hasNext()) {
			Task task = iter.next();
			String[] details = task.getDetails().split(" ");
			
			//For each of the keywords, compare with each word of task details. 
			//If the keyword is found in the task details, found = true, else found = false
			//After comparing with all the keywords, if found remain true, add the task into
			//search result. Reset found to false and repeat for the next task.
			for(int j = 0; j < keyWords.length; j++) {
				for(int k = 0; k < details.length; k++) {
					if(details[k].toLowerCase().startsWith(keyWords[j].toLowerCase())) {
						found = true;
						break;
					} else {
						found = false;
					}
				}
				if(!found) {
					break;
				}
			}
			if(found) {
				searchedResult.add(task);
			} 
			found = false;
		}
	}
	
	//Search all the task.
	private void searchEveryTask(Iterator<Task> iter) {
		while(iter.hasNext()) {
			searchedResult.add(iter.next());
		}
	}
	
	//Search all task that is done.
	private void searchDoneTask(Iterator<Task> iter) {
		while(iter.hasNext()) {
			Task task = iter.next();
			if(task.isDone()) {
				searchedResult.add(task);
			}
		}
	}
	
	//Search all task that is overdue.
	private void searchOverdueTask(Iterator<Task> iter) {
		while(iter.hasNext()) {
			Task task = iter.next();
			TDTDateAndTime dnt = task.getDateAndTime();
			if(dnt.isOverdue()) {
				searchedResult.add(task);
			}
		}
	}
	
	

	//-------------------------------Getters & Setters-----------------------------------
	public String getSearchedWords() {
		return searchedWords;
	}
	public void setSearchedWords(String searchedWords) {
		this.searchedWords = searchedWords;
	}

	public ArrayList<Task> getSearchedResult() {
		return searchedResult;
	}

	public void setSearchedResult(ArrayList<Task> searchedResult) {
		this.searchedResult = searchedResult;
	}

	private String getSearchDate() {
		return searchDate;
	}

	private void setSearchDate(String searchDate) {
		this.searchDate = searchDate;
	}



}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\SearchCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\ShowCommand.java
	 */

package todothis.logic.command;

import java.util.ArrayList;
import java.util.Iterator;

import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class ShowCommand extends Command {
	public static final String MESSAGE_UNDO_SHOW = "Undo show";
	public static final String MESSAGE_SHOW_FEEDBACK = "Show selected labels";
	
	private String labelName;
	private ArrayList<String> prevHideList;
	
	/**
	 * Construct a ShowCommand object.
	 * @param labelName
	 */
	public ShowCommand(String labelName) {
		super(COMMANDTYPE.SHOW);
		this.setLabelName(labelName.toUpperCase());
	}
	
	
	/**
	 * Show all the given labels and hide the rest.
	 */
	public String execute(TDTDataStore data) {
		prevHideList = copyHideList(data.getHideList());
		String[] labelNames = getLabelName().split(" ");
		Iterator<String> iter = data.getLabelIterator();

		if(labelNames[0].equals("")){
			data.getHideList().clear();
		}else {
			while(iter.hasNext()){
				String temp = iter.next();
				if(containInArray(temp, labelNames)){
					data.getHideList().remove(temp);
				}else{
					data.insertToHideList(temp);
				}
			}
		}
		
		data.insertToUndoStack(this);
		return MESSAGE_SHOW_FEEDBACK;
	}
	
	/**
	 * Reverses the effect of execute.
	 */
	@Override
	public String undo(TDTDataStore data) {
		data.setHideList(prevHideList);
		return MESSAGE_UNDO_SHOW;
	}
	
	private ArrayList<String> copyHideList(ArrayList<String> hideList) {
		ArrayList<String> list = new ArrayList<String>();
		for(int i = 0 ; i < hideList.size(); i++) {
			list.add(hideList.get(i));
		}
		return list;
	}
	
	private static boolean containInArray(String label, String[] labelNames) {
		for(int i = 0; i < labelNames.length; i++) {
			if(labelNames[i].toUpperCase().equals(label)) {
				return true;
			}
		}
		return false;
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}
	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\ShowCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\UndoCommand.java
	 */

package todothis.logic.command;

import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.storage.TDTDataStore;

public class UndoCommand extends Command {
	private Command comd;
	
	public static final String MESSAGE_INVALID_UNDO = "Invalid command. No command to undo.";
	
	/**
	 * Construct a UndoCommand object.
	 */
	public UndoCommand() {
		super(COMMANDTYPE.UNDO);
	}

	/**
	 * Pop the previous command from undoStack and execute the undo method.
	 * Add the command into RedoStack.
	 */
	@Override
	public String execute(TDTDataStore data) {

		if (!data.getUndoStack().isEmpty()) {

			Command comd = data.getUndoStack().pop();
			setComd(comd);
			data.getRedoStack().push(comd);

			return comd.undo(data);
		} else {
			return MESSAGE_INVALID_UNDO;
		}
	}

	@Override
	public String undo(TDTDataStore data) {

		return null;
	}

	public Command getComd() {
		return comd;
	}

	public void setComd(Command comd) {
		this.comd = comd;
	}

	
	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\command\UndoCommand.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\parser\ITDTParser.java
	 */

package todothis.logic.parser;

import todothis.logic.command.Command;

//Interface for parser
public interface ITDTParser {
	
	public enum COMMANDTYPE {
		REMIND, ADD, DELETE, HIDE, SEARCH, REDO, EDIT, DONE, 
		UNDO, LABEL, SHOW, HELP, INVALID, EXIT;
	}
	
	/**
	 * Takes in userCommand and return a commmand object using the below constructor
	 * Validates userCommand and make sure that command is valid.
	 * 
	 * public Command(COMMANDTYPE commandType, String labelName, int taskID, 
	 * String commandDetails, String dueDate, String dueTime, boolean isHighPriority)
			
	 * @param userCommand
	 * @return Command
	 */
	public Command parse(String userCommand);
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\parser\ITDTParser.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\TDTController.java
	 */

package todothis.logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;

import todothis.commons.Task;
import todothis.logic.command.AddCommand;
import todothis.logic.command.Command;
import todothis.logic.command.EditCommand;
import todothis.logic.command.RedoCommand;
import todothis.logic.command.SearchCommand;
import todothis.logic.parser.ITDTParser.COMMANDTYPE;
import todothis.logic.parser.TDTParser;
import todothis.storage.TDTDataStore;


/**
 * 
 * TDTController class control the logic flow of TodoThis
 *
 */
public class TDTController  {
	public static final int TASK_VIEW = 0;
	public static final int SEARCH_VIEW = 1;
	public static final int HELP_VIEW = 2;
	
	private TDTParser parser;
	private TDTDataStore dataStore;
	private int viewMode = 0;
	private int scrollVal = -1;
	private ArrayList<Task> highlightTask;
	private Task addedTask;
	private ArrayList<Task> searchedTask;
	private Command cmd;
	
	public TDTController(String fileName) {
		this.parser = new TDTParser();
		this.setData(new TDTDataStore(fileName));
		
	}
	
	/**
	 * Parse the userCommand and execute the returned command. 
	 * Writes to file after each operation.
	 * @param userCommand
	 * @return feedback of execution
	 */
	public String executeCommand(String userCommand) {
		Command command = parser.parse(userCommand);
		this.setCmd(command);
		String feedback = command.execute(dataStore);
		
		//Clear Redo stack if comd != undo/redo
		if(command.getCommandType() != COMMANDTYPE.UNDO &&
				command.getCommandType() != COMMANDTYPE.REDO) {
			dataStore.getRedoStack().clear();
		}
		
		if(command.getCommandType() == COMMANDTYPE.REDO) {
			if(((RedoCommand)command).getComd() != null) {
				command = ((RedoCommand)command).getComd();
			}
		}
		
		//Change view mode
		if(command.getCommandType() == COMMANDTYPE.SEARCH) {
			setViewMode(SEARCH_VIEW);
			setSearchedTask(((SearchCommand)command).getSearchedResult());
		} else if(command.getCommandType() == COMMANDTYPE.HELP) {
			setViewMode(HELP_VIEW);
		} else {
			setViewMode(TASK_VIEW);
		}
		
		//Set tasks to be highlighted
		if(command.getCommandType() == COMMANDTYPE.EDIT) {
			EditCommand comd = (EditCommand)command;
			setHighlightTask(comd.getTargetTask());
		} else if(command.getCommandType() == COMMANDTYPE.ADD) {
			AddCommand comd = (AddCommand)command;
			setHighlightTask(comd.getTargetTask());
		} else {
			setHighlightTask(null);
		}
		
		//Set scroll value
		if(command.getCommandType() == COMMANDTYPE.ADD) {
			AddCommand comd = (AddCommand)command;
			setScrollVal(comd.getTaskID());
			setAddedTask(comd.getAddedTask());
		} else if(command.getCommandType() == COMMANDTYPE.LABEL) {
			setScrollVal(0);
		} else if(command.getCommandType() == COMMANDTYPE.EDIT) {
			EditCommand comd = (EditCommand)command;
			setAddedTask(comd.getEditedTask());
			setScrollVal(-1);
		}else {
			setScrollVal(-1);
		}
		
		this.writeToFile();
		return feedback;
		
	}
	
	/**
	 * Get the iterator of hide label.
	 * @return
	 */
	public Iterator<String> getHideIter() {
		return dataStore.getHideList().iterator();
	}
	
	/**
	 * Return if the given laben is in the taskMap
	 * @param label
	 * @return
	 */
	public boolean isInLabelMap(String label) {
		return dataStore.getTaskMap().containsKey(label.toUpperCase());
	}
	
	/**
	 * Return true if the given label is in the hideList. Return false otherwise.
	 * @param label
	 * @return
	 */
	public boolean isHideLabel(String label) {
		return dataStore.getHideList().contains(label);
	}
	
	/**
	 * Get all the task in the taskMap and return as a iterator.
	 * @return the iterator containing all the task
	 */
	public Iterator<Task> getTaskIterator() {
		return dataStore.getTaskIterator();
	}
	
	/**
	 * Get all the label in the taskMap and return it as a iterator
	 * @return the iterator containing all the labels in taskMap.
	 */
	public Iterator<String> getLabelIterator() {
		return dataStore.getLabelIterator();
	}
	
	/**
	 * Return the ArrayList of task associated with the given label
	 * @param label
	 * @return ArrayList of task
	 */
	public ArrayList<Task> getTaskListFromLabel(String label) {
		return dataStore.getTaskMap().get(label.toUpperCase());
	}
	
	/**
	 * Return the number of task in the label.
	 * @param label
	 * @return
	 */
	public int getLabelSize(String label) {
		return dataStore.getLabelSize(label.toUpperCase());
	}
	
	/**
	 * Get the specific task object from labelName and taskId.
	 * @param label
	 * @param id
	 * @return
	 */
	public Task getTask(String label, int id) {
		return this.getTaskListFromLabel(label.toUpperCase()).get(id - 1);
	}

	/**
	 * Return the string of current label.
	 * @return
	 */
	public String getCurrLabel() {
		return dataStore.getCurrLabel();
	}
	
	/**
	 * Read from the file fileName.txt and store the content in the TDTDataStore object .
	 * @throws IOException if unable to initialize
	 */
	public void readAndInitialize() throws IOException {
		this.getData().readAndInitialize();
	}
	
	/**
	 * Write to the file at fileName.txt
	 */
	public void writeToFile() {
		this.getData().writeToFile();
	}
	
	//-----------------------------------GETTERS & SETTERS-----------------------------------
	public ArrayList<String> getAutoWords() {
		return dataStore.getAutoWords();
	}
	
	public int getViewMode() {
		return viewMode;
	}

	public void setViewMode(int viewMode) {
		this.viewMode = viewMode;
	}

	public ArrayList<Task> getHighlightTask() {
		return highlightTask;
	}

	public void setHighlightTask(ArrayList<Task> highlightTask) {
		this.highlightTask = highlightTask;
	}

	public int getScrollVal() {
		return scrollVal;
	}

	public void setScrollVal(int scrollVal) {
		this.scrollVal = scrollVal;
	}

	public ArrayList<Task> getSearchedTask() {
		return searchedTask;
	}

	public void setSearchedTask(ArrayList<Task> searchedTask) {
		this.searchedTask = searchedTask;
	}

	public Task getAddedTask() {
		return addedTask;
	}

	public void setAddedTask(Task addedTask) {
		this.addedTask = addedTask;
	}

	public TDTDataStore getData() {
		return dataStore;
	}

	public void setData(TDTDataStore data) {
		this.dataStore = data;
	}

	public Command getCmd() {
		return cmd;
	}

	public void setCmd(Command cmd) {
		this.cmd = cmd;
	}




}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\TDTController.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\storage\TDTDataStore.java
	 */

package todothis.storage;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Stack;

import todothis.commons.TDTCommons;
import todothis.commons.Task;
import todothis.logic.command.Command;

/**
 * 
 * TDTDataStore holds all the data required by TodoThis during runtime.
 *
 */
public class TDTDataStore {
	private HashMap<String, ArrayList<Task>> taskMap;
	private String currLabel = TDTCommons.DEFAULT_LABEL;
	private Stack<Command> undoStack;
	private Stack<Command> redoStack;
	private ArrayList<String> hideList;
	private ArrayList<String> autoWords;
	private String fileName;
	private TDTFileHandler file;
	
	/**
	 * Construct a new TDTDataStore. All read and write operations will be at the fileName provided
	 * @param fileName
	 */
	public TDTDataStore(String fileName) {
		setFileName(fileName);
		setTaskMap(new HashMap<String, ArrayList<Task>>());
		setUndoStack(new Stack<Command>());
		setRedoStack(new Stack<Command>());
		setHideList(new ArrayList<String>());
		taskMap.put(currLabel, new ArrayList<Task>());
		setAutoWords(new ArrayList<String>());
		initializeWordsForAutoComplete();
		this.file = new TDTFileHandler(this);
	}
	
	/**
	 * Write to the file at fileName.txt
	 */
	public void writeToFile() {
		file.write();
	}
	
	/**
	 * Read from the file fileName.txt and store the content in the TDTDataStore object .
	 * @throws IOException if unable to initialize
	 */
	public void readAndInitialize() throws IOException {
		file.readAndInitialize();
	}
	
	/**
	 * Get all the task in the taskMap and return as a iterator.
	 * @return the iterator containing all the task
	 */
	public Iterator<Task> getTaskIterator() {
		return new TaskIterator(this.getTaskMap());
	}
	
	/**
	 * Insert word to the auto complete dictionary.
	 * @param label - The word to added to autocomplete
	 */
	public void insertToAutoWords(String label) {
		autoWords.add(label);
		Collections.sort(autoWords);
	}
	
	/**
	 * Return the number or task in the label.
	 * @param labelName
	 * @return the number or task in the label
	 */
	public int getLabelSize(String labelName) {
		return this.getTaskMap().get(labelName).size();
	}
	
	
	/**
	 * Insert the command to undoStack
	 * @param comd - The command that have just been executed.
	 */
	public void insertToUndoStack(Command comd) {
		undoStack.add(comd);
	}
	
	/**
	 * Get all the label in the taskMap and return it as a iterator
	 * @return the iterator containing all the labels in taskMap.
	 */
	public Iterator<String> getLabelIterator() {
		return taskMap.keySet().iterator();
	}	
	
	/**
	 * Insert the label to HideList
	 * @param label - to be hidden from view
	 */
	public void insertToHideList(String label) {
		if(!hideList.contains(label)) {
			hideList.add(label);
		}
	}
	
	/**
	 * Return the taskList associated with the labelname.
	 * @param label
	 * @return Return the taskList associated with the labelname.
	 */
	public ArrayList<Task> getTaskListFromLabel(String label) {
		return this.getTaskMap().get(label.toUpperCase());
	}
	
	/**
	 * Add task to the taskMap
	 * @param task
	 */
	public void addTask(Task task) {
		this.getTaskMap().get(task.getLabelName()).add(task);
	}
	
	
	private void initializeWordsForAutoComplete() {
		autoWords.add("DELETE");
		autoWords.add("DONE");
		autoWords.add("REDO");
		autoWords.add("UNDO");
		autoWords.add("HIDE");
		autoWords.add("SHOW");
		autoWords.add("EDIT");
		autoWords.add("LABEL");
		autoWords.add("SEARCH");
		autoWords.add("REMIND");
		autoWords.add("EXIT");
		autoWords.add("HELP");
		autoWords.add("TODOTHIS");
		Collections.sort(autoWords);
	}
	
	private class TaskIterator implements Iterator<Task>{
		private LinkedList<Task> iterQ;
		
		TaskIterator(HashMap<String,ArrayList<Task>> hmap) {
			iterQ = new LinkedList<Task>();
			Iterator<ArrayList<Task>> tasks = hmap.values().iterator();
			while(tasks.hasNext()) {
				ArrayList<Task> arrayTask = tasks.next();
				for(int i = 0; i < arrayTask.size(); i++) {
					iterQ.add(arrayTask.get(i));
				}
			}
			 
		}
		
		@Override
		public boolean hasNext() {
			return !iterQ.isEmpty();
		}

		@Override
		public Task next() {
			return iterQ.poll();
		}

		@Override
		public void remove() {
			// TODO Auto-generated method stub
			
		}
		
	}
	
	
	public HashMap<String, ArrayList<Task>> getTaskMap() {
		return taskMap;
	}
	public void setTaskMap(HashMap<String, ArrayList<Task>> taskMap) {
		this.taskMap = taskMap;
	}
	public String getCurrLabel() {
		return currLabel;
	}
	public void setCurrLabel(String currLabel) {
		this.currLabel = currLabel;
	}
	public Stack<Command> getUndoStack() {
		return undoStack;
	}
	public void setUndoStack(Stack<Command> undoStack) {
		this.undoStack = undoStack;
	}
	public Stack<Command> getRedoStack() {
		return redoStack;
	}
	public void setRedoStack(Stack<Command> redoStack) {
		this.redoStack = redoStack;
	}
	public ArrayList<String> getHideList() {
		return hideList;
	}
	public void setHideList(ArrayList<String> hideList) {
		this.hideList = hideList;
	}
	public ArrayList<String> getAutoWords() {
		return autoWords;
	}
	public void setAutoWords(ArrayList<String> autoWords) {
		this.autoWords = autoWords;
	}

	public TDTFileHandler getFile() {
		return file;
	}

	public void setFile(TDTFileHandler file) {
		this.file = file;
	}

	public String getFileName() {
		return fileName;
	}

	public void setFileName(String fileName) {
		this.fileName = fileName;
	}
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\storage\TDTDataStore.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTCommandTest.java
	 */

package todothis.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import todothis.commons.TDTCommons;
import todothis.commons.TDTDateAndTime;
import todothis.commons.Task;
import todothis.logic.command.AddCommand;
import todothis.logic.command.DeleteCommand;
import todothis.logic.command.DoneCommand;
import todothis.logic.command.EditCommand;
import todothis.logic.command.HideCommand;
import todothis.logic.command.LabelCommand;
import todothis.logic.command.RemindCommand;
import todothis.logic.command.SearchCommand;
import todothis.logic.command.ShowCommand;
import todothis.storage.TDTDataStore;

public class TDTCommandTest {
	private TDTDataStore testData;
	
	@Before
	public void resetDataStore() {
		testData = new TDTDataStore("testCommand");
	}
	
	//Normal case of adding a floating task and priority task
	@Test
	public void testAddCommand1() {
		String task1 = "normal task";
		String task2 = "priority task";
		String label = testData.getCurrLabel();
		
		AddCommand comd = new AddCommand(task1, new TDTDateAndTime(), false);
		assertEquals(String.format(AddCommand.MESSAGE_ADD_FEEDBACK, label), comd.execute(testData));
		
		comd = new AddCommand(task2, new TDTDateAndTime(), true);
		assertEquals(String.format(AddCommand.MESSAGE_ADD_FEEDBACK, label), comd.execute(testData));
		
		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(2, taskList.size());
		assertTrue(task2.equals(taskList.get(0).getDetails()));
		assertTrue(taskList.get(0).isHighPriority());
		assertTrue(task1.equals(taskList.get(1).getDetails()));
		assertFalse(taskList.get(1).isHighPriority());
	}
	
	//Error case of adding task with invalid data/time
	@Test
	public void testAddCommand2() {
		String task1 = "invalid task";
		String label = testData.getCurrLabel();
		
		AddCommand comd = new AddCommand(task1, new TDTDateAndTime("04/11/2014",
				"03/11/2014", "null", "null"), false);
		assertEquals(AddCommand.MESSAGE_INVALID_END_DATE, comd.execute(testData));
		
		comd = new AddCommand(task1, new TDTDateAndTime("04/20/2014",
				"40/11/2014", "null", "null"), false);
		assertEquals(AddCommand.MESSAGE_INVALID_DATE_TIME_FORMAT, comd.execute(testData));
		
		comd = new AddCommand(task1, new TDTDateAndTime("null",
				"null", "22:00", "20:00"), false);
		assertEquals(AddCommand.MESSAGE_INVALID_END_TIME, comd.execute(testData));
		
		comd = new AddCommand(task1, new TDTDateAndTime("null",
				"null", "30:00", "40:00"), false);
		assertEquals(AddCommand.MESSAGE_INVALID_DATE_TIME_FORMAT, comd.execute(testData));
		
		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(0, taskList.size());
	}
	
	//Normal case of deleting specific task from current label
	@Test
	public void testDeleteTask1() {
		String label = testData.getCurrLabel();
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));
		
		DeleteCommand comd = new DeleteCommand("", 2);
		assertEquals(DeleteCommand.MESSAGE_DELETE_TASK, comd.execute(testData));
		
		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(2, taskList.size());
		assertTrue(taskList.get(0).getDetails().equals("Task 1"));
		assertTrue(taskList.get(1).getDetails().equals("Task 3"));
	}
	
	//Normal case of deleting specific task from specific label
	@Test
	public void testDeleteTask2() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		DeleteCommand comd = new DeleteCommand(label, 2);
		comd.execute(testData);

		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(2, taskList.size());
		assertTrue(taskList.get(0).getDetails().equals("Task 1"));
		assertTrue(taskList.get(1).getDetails().equals("Task 3"));
	}
	
	//Boundary case of deleting specific task from specific label
	@Test
	public void testDeleteTask3() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		DeleteCommand comd = new DeleteCommand(label, 3);
		comd.execute(testData);

		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(2, taskList.size());
		assertTrue(taskList.get(0).getDetails().equals("Task 1"));
		assertTrue(taskList.get(1).getDetails().equals("Task 2"));
	}

	//Error case of deleting specific task from specific label
	@Test
	public void testDeleteTask4() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		DeleteCommand comd = new DeleteCommand(label, 5);
		assertEquals(DeleteCommand.MESSAGE_INVALID_LABEL_TASKID, comd.execute(testData));
		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(3, taskList.size());
		
		comd = new DeleteCommand(label, -2);
		assertEquals(DeleteCommand.MESSAGE_INVALID_LABEL_TASKID, comd.execute(testData));
		assertEquals(3, taskList.size());
	}
	
	//Normal Case of editing a task
	@Test
	public void testEditCommand1() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));
		
		EditCommand comd = new EditCommand(label, 2, "EDITED", new TDTDateAndTime(), false);
		assertEquals(EditCommand.MESSAGE_EDIT_FEEDBACK, comd.execute(testData));
		
		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(3, taskList.size());
		assertEquals("EDITED", taskList.get(1).getDetails());
		
	}
	
	//Boundary Case of editing a task
	@Test
	public void testEditCommand2() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		EditCommand comd = new EditCommand(label, 3, "EDITED", new TDTDateAndTime(), false);
		assertEquals(EditCommand.MESSAGE_EDIT_FEEDBACK, comd.execute(testData));

		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(3, taskList.size());
		assertEquals("EDITED", taskList.get(2).getDetails());

	}
	
	//Error Case of editing a task
	@Test
	public void testEditCommand3() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		EditCommand comd = new EditCommand(label, 5, "EDITED",
				new TDTDateAndTime("04/11/2014", "01/11/2014", "null", "null"), false);
		assertEquals(EditCommand.MESSAGE_INVALID_LABEL_TASKID, comd.execute(testData));

		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(3, taskList.size());
		assertEquals("Task 3", taskList.get(2).getDetails());

	}
	
	//Normal case of marking a task done
	@Test
	public void testDoneCommand1() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		DoneCommand comd = new DoneCommand(label, 2);
		assertEquals(DoneCommand.MESSAGE_DONE_TASK_FEEDBACK, comd.execute(testData));

		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(3, taskList.size());
		assertTrue(taskList.get(1).isDone());
		assertFalse(taskList.get(0).isDone());
		assertFalse(taskList.get(2).isDone());
	}
	
	//Boundary case of marking a task done
	@Test
	public void testDoneCommand2() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		DoneCommand comd = new DoneCommand(label, 3);
		assertEquals(DoneCommand.MESSAGE_DONE_TASK_FEEDBACK, comd.execute(testData));

		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(3, taskList.size());
		assertTrue(taskList.get(2).isDone());
		assertFalse(taskList.get(0).isDone());
		assertFalse(taskList.get(1).isDone());
	}
	
	//Error case of marking a task done
	@Test
	public void testDoneCommand3() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		DoneCommand comd = new DoneCommand(label, -5);
		assertEquals(DoneCommand.MESAGE_INVALID_LABEL_TASKID, comd.execute(testData));

		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals(3, taskList.size());
		assertFalse(taskList.get(2).isDone());
		assertFalse(taskList.get(0).isDone());
		assertFalse(taskList.get(1).isDone());
	}
	
	//Normal case of hiding two label
	@Test
	public void testHideCommand1() {
		String label1 = "TEST1";
		String label2 = "TEST2";
		testData.getTaskMap().put(label1, new ArrayList<Task>());
		testData.getTaskMap().put(label2, new ArrayList<Task>());
		
		HideCommand comd = new HideCommand(label1 + " " + label2);
		assertEquals(HideCommand.MESSAGE_HIDE_FEEDBACK, comd.execute(testData));
		
		assertTrue(testData.getHideList().contains(label1));
		assertTrue(testData.getHideList().contains(label2));
		assertFalse(testData.getHideList().contains(testData.getCurrLabel()));
	}
	
	//Error case of hiding invalid label
	@Test
	public void testHideCommand2() {
		String label1 = "TEST1";
		String label2 = "TEST2";
		testData.getTaskMap().put(label1, new ArrayList<Task>());
		testData.getTaskMap().put(label2, new ArrayList<Task>());
		
		HideCommand comd = new HideCommand("Invalid");
		assertEquals(HideCommand.MESSAGE_HIDE_FEEDBACK, comd.execute(testData));
		
		assertFalse(testData.getHideList().contains(label1));
		assertFalse(testData.getHideList().contains(label2));
		assertFalse(testData.getHideList().contains(testData.getCurrLabel()));
	}
	
	//Test creating label and changing label directory
	@Test
	public void testLabelCommand() {
		String label = "TEST";
		
		LabelCommand comd = new LabelCommand(label);
		
		assertEquals(String.format(LabelCommand.MESSAGE_CREATE_LABEL_FEEDBACK, label), 
				comd.execute(testData));
		assertEquals(2, testData.getTaskMap().size());
		assertEquals(label, testData.getCurrLabel());
		
		comd = new LabelCommand(TDTCommons.DEFAULT_LABEL);
		assertEquals(String.format(LabelCommand.MESSAGE_LABEL_FEEDBACK, TDTCommons.DEFAULT_LABEL),
				comd.execute(testData));
		assertEquals(TDTCommons.DEFAULT_LABEL, testData.getCurrLabel());
	}
	
	//Normal case of showing two label
	@Test
	public void testShowCommand1() {
		String label1 = "TEST1";
		String label2 = "TEST2";
		testData.getTaskMap().put(label1, new ArrayList<Task>());
		testData.getTaskMap().put(label2, new ArrayList<Task>());
		
		ShowCommand comd = new ShowCommand(label1 + " " + label2);
		assertEquals(ShowCommand.MESSAGE_SHOW_FEEDBACK, comd.execute(testData));
		
		assertFalse(testData.getHideList().contains(label1));
		assertFalse(testData.getHideList().contains(label2));
		assertTrue(testData.getHideList().contains(testData.getCurrLabel()));
	}

	//Error case of showing invalid label
	@Test
	public void testShowCommand2() {
		String label1 = "TEST1";
		String label2 = "TEST2";
		testData.getTaskMap().put(label1, new ArrayList<Task>());
		testData.getTaskMap().put(label2, new ArrayList<Task>());

		ShowCommand comd = new ShowCommand("Invalid");
		assertEquals(ShowCommand.MESSAGE_SHOW_FEEDBACK, comd.execute(testData));

		assertTrue(testData.getHideList().contains(label1));
		assertTrue(testData.getHideList().contains(label2));
		assertTrue(testData.getHideList().contains(testData.getCurrLabel()));
	}
	
	//Normal case of adding and removing reminder 
	@Test
	public void testRemindCommand() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));

		RemindCommand comd = new RemindCommand(label, 2, "25/12/2014 12pm");
		assertEquals(String.format(RemindCommand.MESSAGE_REMIND_FEEDBACK, "25/12/2014 12:00"),
				comd.execute(testData));
		ArrayList<Task> taskList = testData.getTaskListFromLabel(label);
		assertEquals("25/12/2014 12:00", taskList.get(1).getRemindDateTime());
		assertTrue(taskList.get(1).hasReminder());
		
		comd = new RemindCommand(label, 2, "");
		assertEquals(String.format(RemindCommand.MESSAGE__REMOVE_REMIND_FEEDBACK, "25/12/2014 12:00"),
				comd.execute(testData));
		assertFalse(taskList.get(1).hasReminder());
	}
	
	//Test search everything
	@Test
	public void testSearchCommand1() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "This is task 4",
				new TDTDateAndTime(), false));
		
		SearchCommand comd = new SearchCommand("");
		assertEquals(String.format(SearchCommand.SEARCH_FEEDBACK, 4), comd.execute(testData));
	}

	//Test search keyWords
	@Test
	public void testSearchCommand2() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "This is task 4",
				new TDTDateAndTime(), false));

		SearchCommand comd = new SearchCommand("th");
		assertEquals(String.format(SearchCommand.SEARCH_FEEDBACK, 1), comd.execute(testData));
		assertEquals("This is task 4", comd.getSearchedResult().get(0).getDetails());
		
		comd = new SearchCommand("task 3");
		assertEquals(String.format(SearchCommand.SEARCH_FEEDBACK, 1), comd.execute(testData));
		assertEquals("Task 3", comd.getSearchedResult().get(0).getDetails());
	}
	
	//Test search Date and keyword and Date
	@Test
	public void testSearchCommand3() {
		String label = "TEST";
		testData.getTaskMap().put(label, new ArrayList<Task>());
		testData.addTask(new Task(1, label , "Task 1",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(2, label, "Task 2",
				new TDTDateAndTime(), false));
		testData.addTask(new Task(3, label, "Task 3",
				new TDTDateAndTime("12/12/2014", "null", "null", "null"), false));
		testData.addTask(new Task(3, label, "This is task 4",
				new TDTDateAndTime("12/12/2014", "null", "null", "null"), false));

		SearchCommand comd = new SearchCommand("@12/12/2014");
		assertEquals(String.format(SearchCommand.SEARCH_FEEDBACK, 2), comd.execute(testData));
		assertEquals("Task 3", comd.getSearchedResult().get(0).getDetails());
		assertEquals("This is task 4", comd.getSearchedResult().get(1).getDetails());

		comd = new SearchCommand("this @12/12/2014");
		assertEquals(String.format(SearchCommand.SEARCH_FEEDBACK, 1), comd.execute(testData));
		assertEquals("This is task 4", comd.getSearchedResult().get(0).getDetails());
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTCommandTest.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\TodoThis.java
	 */

package todothis;

import java.awt.EventQueue;

import todothis.gui.TDTGUI;

public class TodoThis {
	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {

		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					final TDTGUI frame = new TDTGUI();
					frame.getFeedbackArea().setText(frame.doInit());
					
					javax.swing.SwingUtilities.invokeLater(new Runnable() {
						public void run() {
							frame.getScrollPane().getVerticalScrollBar().setValue(0);
						}
					});
					frame.sysTray();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\TodoThis.java





