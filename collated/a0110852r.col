//@author: a0110852r



	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTDateAndTime.java
	 */

package todothis.commons;

import java.util.Calendar;
import java.util.TimeZone;

/**
 * This TDTDateAndTime class stores the date and time information of a task to
 * be created.
 *
 */
public class TDTDateAndTime implements Comparable<TDTDateAndTime> {
	// store converted date format dd/mm/yyyy
	private String startDate = "null";
	private String endDate = "null";

	// store converted time format XX:XX 24hrs format
	private String startTime = "null";
	private String endTime = "null";

	private boolean isTimedTask = false;
	private boolean isDeadlineTask = false;

	private static Calendar cal;

	/**
	 * Constructor
	 * 
	 * @param startDate
	 * @param endDate
	 * @param startTime
	 * @param endTime
	 */
	public TDTDateAndTime(String startDate, String endDate, String startTime,
			String endTime) {
		this.startDate = startDate;
		this.endDate = endDate;
		this.startTime = startTime;
		this.endTime = endTime;
		if (!getStartDate().equals("null") || !getStartTime().equals("null")) {
			// Timed task will always have start date or start time or both.
			isTimedTask = true;
		} else if (!getEndDate().equals("null") || !getEndTime().equals("null")) {
			// Date and time info will be stored under endDate and endTime for
			// deadline task
			isDeadlineTask = true;
		}
	}

	/**
	 * Default Constructor
	 */
	public TDTDateAndTime() {
		this.startDate = "null";
		this.endDate = "null";
		this.startTime = "null";
		this.endTime = "null";
	}

	// -----------------------Getters-------------------------------
	/**
	 * This method gets the value of startDate.
	 * 
	 * @return String This returns startDate.
	 */
	public String getStartDate() {
		return startDate;
	}

	/**
	 * This method gets the value of endDate.
	 * 
	 * @return String This returns endDate.
	 */
	public String getEndDate() {
		return endDate;
	}

	/**
	 * This method gets the value of startTime.
	 * 
	 * @return String This returns startTime.
	 */
	public String getStartTime() {
		return startTime;
	}

	/**
	 * This method gets the value of endTime.
	 * 
	 * @return String This returns endTime.
	 */
	public String getEndTime() {
		return endTime;
	}

	/**
	 * This method gets boolean value of isTimedTask.
	 * 
	 * @return boolean This returns true if its a timed task.
	 */
	public boolean isTimedTask() {
		return isTimedTask;
	}

	/**
	 * This method gets boolean value of isDeadlineTask.
	 * 
	 * @return String This returns true if its a deadline task.
	 */
	public boolean isDeadlineTask() {
		return isDeadlineTask;
	}

	/**
	 * This method displays the date and time information of the task. The
	 * display string depends on the type of task.
	 * 
	 * @return String This return the date and time information of the task.
	 * 
	 */
	public String display() {
		String dateAndTimeContents = "";
		if (isDeadlineTask) {
			dateAndTimeContents = dateAndTimeContents + "Due: ";
			if (!getEndDate().equals("null")) {
				dateAndTimeContents = dateAndTimeContents
						+ TDTDateMethods.changeToDayOfWeek(getEndDate()) + "\t"
						+ TDTDateMethods.changeDateFormatDisplay(getEndDate())
						+ "\t";
			}
			if (!getEndTime().equals("null")) {
				dateAndTimeContents = dateAndTimeContents
						+ TDTTimeMethods.changeTimeFormatDisplay(getEndTime());
			}
			dateAndTimeContents = dateAndTimeContents + "<br>";
		} else if (isTimedTask) {
			dateAndTimeContents = dateAndTimeContents + "Start: ";
			if (!getStartDate().equals("null")) {
				dateAndTimeContents = dateAndTimeContents
						+ TDTDateMethods.changeToDayOfWeek(getStartDate())
						+ "\t"
						+ TDTDateMethods
								.changeDateFormatDisplay(getStartDate()) + "\t";
			}
			if (!getStartTime().equals("null")) {
				dateAndTimeContents = dateAndTimeContents
						+ TDTTimeMethods
								.changeTimeFormatDisplay(getStartTime());
			}
			dateAndTimeContents = dateAndTimeContents + "<br>";
			// checks if timed task has a end date or end time
			if (!getEndDate().equals("null") || !getEndTime().equals("null")) {
				dateAndTimeContents = dateAndTimeContents + "End: ";
				if (!getEndDate().equals("null")) {
					dateAndTimeContents = dateAndTimeContents
							+ TDTDateMethods.changeToDayOfWeek(getEndDate())
							+ "\t"
							+ TDTDateMethods
									.changeDateFormatDisplay(getEndDate())
							+ "\t";
				}
				if (!getEndTime().equals("null")) {
					dateAndTimeContents = dateAndTimeContents
							+ TDTTimeMethods
									.changeTimeFormatDisplay(getEndTime());
				}
				dateAndTimeContents = dateAndTimeContents + "<br>";
			}
		}
		return dateAndTimeContents;
	}

	/**
	 * This method checks if the task is overdue or has past.
	 * 
	 * @return boolean This returns true if the task is overdue.
	 */
	public boolean isOverdue() {
		// Get the current date and time
		cal = Calendar.getInstance(TimeZone.getDefault());
		int currentDay = cal.get(Calendar.DATE);
		int currentMonth = cal.get(Calendar.MONTH) + 1;
		int currentYear = cal.get(Calendar.YEAR);

		int currentHour = cal.get(Calendar.HOUR_OF_DAY);
		int currentMinute = cal.get(Calendar.MINUTE);

		String currentDate = currentDay + "/" + currentMonth + "/"
				+ currentYear;
		String currentTime = currentHour + ":" + currentMinute;

		String checkDate = "null";
		String checkTime = "null";

		// Decides on the date and time info to be checked, depending on the
		// type of task
		if (isDeadlineTask) {
			checkDate = getEndDate();
			checkTime = getEndTime();
		} else if (isTimedTask) {
			if (getEndDate().equals("null") && !getEndTime().equals("null")) {
				checkDate = getStartDate();
				checkTime = getEndTime();
			} else if (!getEndDate().equals("null")) {
				checkDate = getEndDate();
				checkTime = getEndTime();
			} else {
				checkDate = getStartDate();
				checkTime = getStartTime();
			}
		}
		// Compare with the current date and time to see if it is overdue
		if (!checkDate.equals("null")) {
			if (TDTDateMethods.compareToDate(currentDate, checkDate) == -1) {
				return true;
			} else if (TDTDateMethods.compareToDate(currentDate, checkDate) == 0) {
				if (!checkTime.equals("null")) {
					if (TDTTimeMethods.compareToTime(currentTime, checkTime) == -1) {
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * This method checks for clashes with other tasks that consist of
	 * TDTDateAndTime object. It checks if the task overlaps with other tasks
	 * that has a start and end timings.
	 * 
	 * @param arg0
	 * @return boolean This returns true if the task clashes with another task
	 *         being compared.
	 */
	public boolean isClash(TDTDateAndTime arg0) {
		boolean isClashTDT = false;
		if (arg0.isTimedTask() == true) {
			if (!this.getStartDate().equals("null")
					&& !this.getStartTime().equals("null")) {
				// Handle cases when "this" task only have start date and time
				if (this.getEndDate().equals("null")
						&& this.getEndTime().equals("null")) {
					isClashTDT = isClashForTHISTaskWithStartDateTimeOnly(arg0);
				}
				// Handle cases when "this" task has end date and end time as
				// well
				if ((!this.getEndDate().equals("null") && !this.getEndTime()
						.equals("null")) && !arg0.getStartDate().equals("null")) {
					// SD=startDate ED=endDate ST=startTime ET=endTime
					// condition where this->has SD ED ST ET and arg0->has SD
					// may have ED may have ST ET
					isClashTDT = isClashForTHISTaskWithEndDateTimeAlso(arg0);
				}
			}
		}
		return isClashTDT;
	}

	private boolean isClashForTHISTaskWithEndDateTimeAlso(TDTDateAndTime arg0) {
		// SDate = 8/10/2014 EDate = 11/10/2014 startArgdate =
		// 10/10/2014
		if (TDTDateMethods.compareToDate(this.getStartDate(),
				arg0.getStartDate()) == 1
				&& TDTDateMethods.compareToDate(this.getEndDate(),
						arg0.getStartDate()) == -1) {
			
			return true;
		}
		
		// SDate = 8/10/2014 EDate = 11/10/2014 Argdate =
		// 8/10/2014 NEED CHECK TIMING
		if (TDTDateMethods.compareToDate(this.getStartDate(),
				arg0.getStartDate()) == 0
				&& TDTDateMethods.compareToDate(this.getEndDate(),
						arg0.getStartDate()) == -1
				&& !arg0.getStartTime().equals("null")) {
			// Timing SDate 8/10/2014 0800 argdate 8/10/2014
			// 0900/0800
			if (TDTTimeMethods.compareToTime(this.getStartTime(),
					arg0.getStartTime()) == 1
					|| TDTTimeMethods.compareToTime(this.getStartTime(),
							arg0.getStartTime()) == 0) {
				
				return true;
			}
		}
		// SDate = 8/10/2014 EDate = 11/10/2014 Argdate =
		// 11/10/2014 NEED CHECK TIMING
		if (TDTDateMethods.compareToDate(this.getStartDate(),
				arg0.getStartDate()) == 1
				&& TDTDateMethods.compareToDate(this.getEndDate(),
						arg0.getStartDate()) == 0
				&& !arg0.getStartTime().equals("null")) {
			// Timing EDate 11/10/2014 0800 argdate 11/10/2014
			// 0700
			if (TDTTimeMethods.compareToTime(this.getEndTime(),
					arg0.getStartTime()) == -1) {
				
				return true;
			}
		}
		// SDate = 8/10/2014 EDate = 8/10/2014 Argdate =
		// 8/10/2014 NEED CHECK TIMING
		if (TDTDateMethods.compareToDate(this.getStartDate(),
				arg0.getStartDate()) == 0
				&& TDTDateMethods.compareToDate(this.getEndDate(),
						arg0.getStartDate()) == 0
				&& !arg0.getStartTime().equals("null")) {
			// Timing date same sTime = 0900 eTime = 1200
			// argtime = 1000/0900
			if ((TDTTimeMethods.compareToTime(this.getStartTime(),
					arg0.getStartTime()) == 1 || TDTTimeMethods.compareToTime(
					this.getStartTime(), arg0.getStartTime()) == 0)
					&& TDTTimeMethods.compareToTime(this.getEndTime(),
							arg0.getStartTime()) == -1) {
				
				return true;
			}
			if (!arg0.getEndTime().equals("null")) {
				if (TDTTimeMethods.compareToTime(this.getStartTime(),
						arg0.getStartTime()) == -1
						&& TDTTimeMethods.compareToTime(this.getEndTime(),
								arg0.getEndTime()) == 1) {
					return true;
				}
			}
		}
		// SDate = 8/10/2014 EDate = 11/10/2014 endArgdate =
		// 10/10/2014
		if (!arg0.getEndDate().equals("null")) {
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getEndDate()) == 1
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == -1) {
				
				return true;
			}
			// SDate = 8/10/2014 EDate = 11/10/2014 endArgdate =
			// 8/10/2014
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getEndDate()) == 0
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == -1
					&& !arg0.getEndTime().equals("null")) {
				// Timing SDate 8/10/2014 0800 argdate 8/10/2014
				// 0900
				if (TDTTimeMethods.compareToTime(this.getStartTime(),
						arg0.getEndTime()) == 1) {
					
					return true;
				}
			}
			// SDate = 8/10/2014 EDate = 11/10/2014 endArgdate =
			// 11/10/2014
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getEndDate()) == 1
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == 0
					&& !arg0.getEndTime().equals("null")) {
				// Timing EDate 11/10/2014 0800 endargdate
				// 11/10/2014 0700/0800
				if (TDTTimeMethods.compareToTime(this.getEndTime(),
						arg0.getEndTime()) == -1
						|| TDTTimeMethods.compareToTime(this.getEndTime(),
								arg0.getEndTime()) == 0) {
					return true;
				}
			}
			// SDate = 8/10/2014 EDate = 8/10/2014 endArgdate =
			// 8/10/2014
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getEndDate()) == 0
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == 0
					&& !arg0.getEndTime().equals("null")) {
				
				if (TDTTimeMethods.compareToTime(this.getStartTime(),
						arg0.getEndTime()) == 1
						&& (TDTTimeMethods.compareToTime(this.getEndTime(),
								arg0.getEndTime()) == -1 || TDTTimeMethods
								.compareToTime(this.getEndTime(),
										arg0.getEndTime()) == 0)) {
					return true;
				}
				if (!arg0.getStartTime().equals("null")) {
					if (TDTTimeMethods.compareToTime(this.getStartTime(),
							arg0.getStartTime()) == -1
							&& TDTTimeMethods.compareToTime(this.getEndTime(),
									arg0.getEndTime()) == 1) {
						return true;
					}
				}
			}
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getStartDate()) == -1
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == 1) {
				return true;
			}
			// when startdate = arg0startdate & enddate<arg0enddate
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getStartDate()) == 0
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == 1) {
				if (!arg0.getStartTime().equals("null")) {
					if (TDTTimeMethods.compareToTime(this.getStartTime(),
							arg0.getStartTime()) == -1) {
						return true;
					}
				}
			}
			// when startdate > arg0startdate & enddate =
			// arg0enddate
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getStartDate()) == -1
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == 0) {
				if (!arg0.getEndTime().equals("null")) {
					if (TDTTimeMethods.compareToTime(this.getEndTime(),
							arg0.getEndTime()) == 1) {
						return true;
					}
				}
			}
			// when startdate = arg0startdate & enddate =
			// arg0enddate
			if (TDTDateMethods.compareToDate(this.getStartDate(),
					arg0.getStartDate()) == 0
					&& TDTDateMethods.compareToDate(this.getEndDate(),
							arg0.getEndDate()) == 0) {
				if (!arg0.getStartTime().equals("null")
						&& !arg0.getEndTime().equals("null")) {
					if (TDTTimeMethods.compareToTime(this.getStartTime(),
							arg0.getStartTime()) == -1
							&& TDTTimeMethods.compareToTime(this.getEndTime(),
									arg0.getEndTime()) == 1) {
						return true;
					}
				}
			}
		}
		return false;
	}

	private boolean isClashForTHISTaskWithStartDateTimeOnly(TDTDateAndTime arg0) {
		if (arg0.getStartDate().equals(this.getStartDate())
				&& arg0.getStartTime().equals(this.getStartTime())) {
			// checks case when startDate and startTime clashes
			// exactly with compared arg0 startDate and startTime
			return true;
		} else {
			// checks for other cases when "this" task startDate and
			// startTime
			// lands between the "arg0" task start and end duration
			if (!arg0.getEndDate().equals("null")) {
				if (TDTDateMethods.compareToDate(this.getStartDate(),
						arg0.getStartDate()) == -1
						&& TDTDateMethods.compareToDate(this.getStartDate(),
								arg0.getEndDate()) == 1) {
					// checks for case when "this" task start date
					// lands between
					// "arg0" task start date and end date
					return true;
				} else if (TDTDateMethods.compareToDate(this.getStartDate(),
						arg0.getStartDate()) == 0
						&& TDTDateMethods.compareToDate(this.getStartDate(),
								arg0.getEndDate()) == 0) {
					if (TDTTimeMethods.compareToTime(this.getStartTime(),
							arg0.getStartTime()) == -1
							&& TDTTimeMethods.compareToTime(
									this.getStartTime(), arg0.getEndTime()) == 1) {
						// checks for the case when "this" task start date =
						// "arg0" task start and end date. hence check for time,
						// if start time lands between the time duration
						return true;
					}
				} else {
					// handles the case when "this" task start date =
					// "arg0" task start date only
					// checks for timing as a result
					if (TDTDateMethods.compareToDate(this.getStartDate(),
							arg0.getStartDate()) == 0) {
						if (TDTTimeMethods.compareToTime(this.getStartTime(),
								arg0.getStartTime()) == -1) {
							return true;
						}
					}
					// handles the case when "this" task start date =
					// "arg0" task end date only
					// checks for timing as a result
					if (TDTDateMethods.compareToDate(this.getStartDate(),
							arg0.getEndDate()) == 0) {
						if (TDTTimeMethods.compareToTime(this.getStartTime(),
								arg0.getEndTime()) == 1) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	/**
	 * compareTo
	 * 
	 * @return int This returns a negative integer, zero, or a positive integer
	 *         as this object is less than, equal to, or greater than the
	 *         specified object.
	 */
	public int compareTo(TDTDateAndTime arg0) {
		String thisDate = "null";
		String thisTime = "null";
		String comparedDate = "null";
		String comparedTime = "null";

		// Determines the date and time info to be used to compare as it varies
		// for each type of task
		if (this.getStartDate().equals("null")) {
			thisDate = this.getEndDate();
		} else {
			thisDate = this.getStartDate();
		}

		if (this.getStartTime().equals("null")) {
			thisTime = this.getEndTime();
		} else {
			thisTime = this.getStartTime();
		}

		if (arg0.getStartDate().equals("null")) {
			comparedDate = arg0.getEndDate();
		} else {
			comparedDate = arg0.getStartDate();
		}

		if (arg0.getStartTime().equals("null")) {
			comparedTime = arg0.getEndTime();
		} else {
			comparedTime = arg0.getStartTime();
		}

		// Compare this.TDTDateAndTime with arg0.TDTDateAndTime
		if (TDTDateMethods.compareToDate(thisDate, comparedDate) == 1) {
			return -1;
		} else if (TDTDateMethods.compareToDate(thisDate, comparedDate) == 0) {
			if (thisTime.equals("null") && !comparedTime.equals("null")) {
				return 1;
			} else if (thisTime.equals("null") && comparedTime.equals("null")) {
				return 0;
			} else if (!thisTime.equals("null") && comparedTime.equals("null")) {
				return -1;
			}

			if (TDTTimeMethods.compareToTime(thisTime, comparedTime) == 1) {
				return -1;
			} else if (TDTTimeMethods.compareToTime(thisTime, comparedTime) == 0) {
				return 0;
			} else {
				return 1;
			}
		} else {
			return 1;
		}
	}
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTDateAndTime.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTDateMethods.java
	 */

package todothis.commons;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/**
 * This TDTDateMethods class stores all the static date related methods which
 * are called by other components of the software.
 * 
	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTDateMethods.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTTimeMethods.java
	 */

	/**
	 * The method converts the old time format HH:mm to a new format h:mm a
	 * (2:30pm) for display.
	 * 
	 * @param time
	 * @return String This returns the time that follows the new time format.
	 */
	public static String changeTimeFormatDisplay(String time) {
		final String OLD_FORMAT = "HH:mm";
		final String NEW_FORMAT = "h:mm a";

		String oldTimeString = time;
		String newTimeString = "";

		SimpleDateFormat sdf = new SimpleDateFormat(OLD_FORMAT);
		Date d = new Date();
		try {
			d = sdf.parse(oldTimeString);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		sdf.applyPattern(NEW_FORMAT);
		newTimeString = sdf.format(d);
		return newTimeString;
	}

	/**
	 * This method checks if the time falls in the valid time range.
	 * @param time
	 * @return boolean This returns true if time is valid and false if
	 *         otherwise.
	 */
	public static boolean isValidTimeRange(String time) {
		if (time.equals("null")) {
			return true;
		}

		String[] timeParts = time.split(":");
		int hours;
		int minutes;

		try {
			hours = Integer.parseInt(timeParts[0]);
			minutes = Integer.parseInt(timeParts[1]);
		} catch (NumberFormatException e) {
			return false;
		}

		if (hours < 24 && hours >= 0 && minutes < 60 && minutes >= 0) {
			return true;
		}
		return false;
	}

	/**
	 * This method compares the two timings and checks if they are the same or
	 * one being later or earlier than another.
	 * 
	 * @param time1
	 * @param time2
	 * @return int This returns a value -1 if time1>time2, value 0 if
	 *         time1=time2 and value 1 if time2>time1.
	 */
	public static int compareToTime(String time1, String time2) {
		String[] time1Parts = time1.split(":");
		String[] time2Parts = time2.split(":");

		assert (TDTTimeMethods.isValidTimeRange(time1));
		assert (TDTTimeMethods.isValidTimeRange(time2));

		int time1Hours = Integer.parseInt(time1Parts[0]);
		int time1Minutes = Integer.parseInt(time1Parts[1]);
		int time2Hours = Integer.parseInt(time2Parts[0]);
		int time2Minutes = Integer.parseInt(time2Parts[1]);

		if (time2Hours > time1Hours) {
			return 1;
		} else if (time2Hours == time1Hours) {
			if (time2Minutes > time1Minutes) {
				return 1;
			} else if (time2Minutes == time1Minutes) {
				return 0;
			} else {
				return -1;
			}
		}
		return -1;
	}

	/**
	 * This method calculates the remaining amount of time left from the current
	 * date and time to the targeted date and time.
	 * 
	 * @param decodedString
	 * @return long This returns the remaining time in seconds.
	 */
	public static long calculateRemainingTime(String decodedString) {
		cal = Calendar.getInstance(TimeZone.getDefault());
		int currentDay = cal.get(Calendar.DATE);
		int currentMonth = cal.get(Calendar.MONTH) + 1;
		int currentYear = cal.get(Calendar.YEAR);

		int currentHour = cal.get(Calendar.HOUR_OF_DAY);
		int currentMinute = cal.get(Calendar.MINUTE);
		int currentSeconds = cal.get(Calendar.SECOND);

		// Include seconds portion to decodedString so as to match the date
		// format
		String reminder = decodedString + ":00";

		String currentDateAndTime = currentDay + "/" + currentMonth + "/"
				+ currentYear + " " + currentHour + ":" + currentMinute + ":"
				+ currentSeconds;
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		Date d1 = null;
		Date d2 = null;
		long remainingTimeInSeconds = 0;

		try {
			d1 = format.parse(currentDateAndTime);
			d2 = format.parse(reminder);

			// In milliseconds
			long diff = d2.getTime() - d1.getTime();

			// Convert to seconds
			remainingTimeInSeconds = diff / 1000;
		} catch (ParseException e) {
			e.printStackTrace();
		}
		return remainingTimeInSeconds;
	}
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\commons\TDTTimeMethods.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\parser\TDTDateAndTimeParser.java
	 */

package todothis.logic.parser;

import java.util.Calendar;
import java.util.TimeZone;

import todothis.commons.TDTCommons;
import todothis.commons.TDTDateAndTime;
import todothis.commons.TDTDateMethods;
import todothis.commons.TDTTimeMethods;

/**
 * This TDTDateAndTimeParser class parses the string of date and time details to
 * be stored as a TDTDateAndTime object. It also provides a method to parse
 * search by date details and another method to parse set reminder details.
 *
 */
public class TDTDateAndTimeParser {
	// store converted date format dd/mm/yyyy
	private String startDate = "null";
	private String endDate = "null";

	// store converted time format XX:XX 24hrs format
	private String startTime = "null";
	private String endTime = "null";

	private static Calendar cal;

	/**
	 * Constructor
	 * 
	 */
	public TDTDateAndTimeParser() {
		this.startDate = "null";
		this.endDate = "null";
		this.startTime = "null";
		this.endTime = "null";
	}

	public static void main(String[] args) {
		System.out.println(TDTDateAndTimeParser
				.decodeSearchDetails("next month"));
	}

	/**
	 * This method parse the date and time details.
	 * 
	 * @param details
	 * @return TDTDateAndTime This returns the object TDTDateAndTime with the
	 *         date and time info
	 */
	public TDTDateAndTime decodeDateAndTimeDetails(String details) {
		boolean endTimeDate = false;
		boolean deadlineEndTimeDate = false;
		int thisOrNextOrFollowing = 0; // this = 1 next = 2 following = 3
		String decodedDate = "";
		String decodedTime = "";
		int nextCount = 0;
		int followingCount = 0;

		String[] parts = details.toLowerCase().split(" ");

		// Get current date
		cal = Calendar.getInstance(TimeZone.getDefault());
		int currentDay = cal.get(Calendar.DATE);
		int currentMonth = cal.get(Calendar.MONTH) + 1;
		int currentYear = cal.get(Calendar.YEAR);
		int currentDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);

		// Goes through the string of words in the details
		for (int a = 0; a < parts.length; a++) {
			parts[a] = TDTCommons.replaceEndStringPunctuation(parts[a]);

			if (isPrepositionTo(parts, a)) {
				endTimeDate = true;
				// resets the value for the next date to be encountered
				nextCount = 0;
				followingCount = 0;
			}

			if (isPrepositionDeadline(parts, a)) {
				deadlineEndTimeDate = true;
			}

			if (parts[a].equals("this")) {
				thisOrNextOrFollowing = 1;
			} else if (parts[a].equals("next")) {
				nextCount++;
				thisOrNextOrFollowing = 2;
			} else if (parts[a].equals("following")) {
				followingCount++;
				thisOrNextOrFollowing = 3;
			}

			if (TDTDateMethods.checkDate(parts[a])) {
				decodedDate = decodeDate(parts, a, currentYear, currentMonth);

				storeDecodedDate(endTimeDate, deadlineEndTimeDate, decodedDate);
			} else if (TDTTimeMethods.checkTime(parts[a])) {
				decodedTime = decodeTime(parts, a);

				storeDecodedTime(endTimeDate, deadlineEndTimeDate, decodedTime);
			} else if (TDTDateMethods.checkDay(parts[a]) != 0) {
				int numOfDaysToAdd = determineDaysToBeAdded(
						thisOrNextOrFollowing, parts, a, currentDayOfWeek,
						nextCount, followingCount);

				decodedDate = TDTDateMethods.addDaysToCurrentDate(currentDay,
						currentMonth, currentYear, numOfDaysToAdd);

				decodedDate = adjustmentToDate(endTimeDate, decodedDate, parts,
						a);

				storeDecodedDate(endTimeDate, deadlineEndTimeDate, decodedDate);
			} else if (TDTDateMethods.checkMonth(parts[a].replaceAll("[0-9~]",
					"")) != 0) {
				decodedDate = decodeMonthFormat(parts, a, currentYear,
						currentMonth);

				storeDecodedDate(endTimeDate, deadlineEndTimeDate, decodedDate);
			}
		}
		if (isOnlyEndDateNull()) {
			endDate = startDate;
		}
		return new TDTDateAndTime(startDate, endDate, startTime, endTime);
	}

	// Handles the case when user inputs a single date with start and end time
	private static boolean isPrepositionTo(String[] parts, int a) {
		return parts[a].equals("to") || parts[a].equals("till")
				|| parts[a].equals("until") || parts[a].equals("-");
	}

	private boolean isOnlyEndDateNull() {
		return !startDate.equals("null") && endDate.equals("null")
				&& !startTime.equals("null") && !endTime.equals("null");
	}

	// Checks for occurrence of deadline related connectors
	private boolean isPrepositionDeadline(String[] parts, int a) {
		return parts[a].equals("by") || parts[a].equals("due")
				|| parts[a].equals("before");
	}

	// This method decodes the date and converts it to the DD/MM/YYYY date
	// format for storage
	// Date formats: 9/12, 9/12/2014, 8-11, 8-11-2015 9/12/12, 091214, 09122014
	private static String decodeDate(String[] parts, int a, int currentYear,
			int currentMonth) {
		String[] dateParts = new String[3];
		String[] datePartsTemp = null;
		if ((parts[a].split("/").length == 3)
				|| (parts[a].split("/").length == 2)) {
			datePartsTemp = parts[a].split("/");
		} else if ((parts[a].split("-").length == 3)
				|| (parts[a].split("-").length == 2)) {
			datePartsTemp = parts[a].split("-");
		} else {
			dateParts[0] = parts[a].substring(0, 2);
			dateParts[1] = parts[a].substring(2, 4);
			if (parts[a].length() == 6) {
				// For date format 091214, it is converted to 09122014
				dateParts[2] = "20" + parts[a].substring(4, 6);
			} else if (parts[a].length() == 8) {
				dateParts[2] = parts[a].substring(4, 8);
			}
		}
		// For date format 9/12, it is converted 9/12/2014
		if (datePartsTemp != null) {
			if (datePartsTemp.length == 2) {
				boolean isMonthInt = true;
				dateParts[0] = datePartsTemp[0];
				dateParts[1] = datePartsTemp[1];

				try {
					Integer.parseInt(dateParts[1]);
				} catch (NumberFormatException e) {
					isMonthInt = false;
				}
				// Checks if the month has past for the current year to
				// determine the year
				// Assumes that user will not type past events of more than a
				// month
				if (isMonthInt) {
					if (currentMonth > Integer.parseInt(datePartsTemp[1])) {
						dateParts[2] = Integer.toString(currentYear + 1);
					} else {
						dateParts[2] = Integer.toString(currentYear);
					}
				}
			} else {
				dateParts = datePartsTemp;
			}
			// For date format 9/12/14, it is converted 9/12/2014
			if (datePartsTemp.length == 3) {
				if (datePartsTemp[2].length() == 2) {
					dateParts[2] = "20" + datePartsTemp[2];
				}
			}
		}
		return dateParts[0] + "/" + dateParts[1] + "/" + dateParts[2];
	}

	// This method decodes the date and converts it to the DD/MM/YYYY date
	// format storage
	// Date formats: 14 dec 2014 / 14 dec 14 / 14 dec
	private static String decodeMonthFormat(String[] parts, int a,
			int currentYear, int currentMonth) {
		String[] tempParts = parts[a].split("~");

		int day = Integer.parseInt(tempParts[0]);
		int month = TDTDateMethods.checkMonth(tempParts[1]);
		int year = 0;

		if (tempParts.length == 3) {
			if (tempParts[2].length() == 2) {
				tempParts[2] = "20" + tempParts[2];
			}
			year = Integer.parseInt(tempParts[2]);
		} else {
			if (currentMonth > month) {
				year = currentYear + 1;
			} else {
				year = currentYear;
			}
		}
		return day + "/" + month + "/" + year;
	}

	// This method determines the number of days to be added from the current
	// date
	private static int determineDaysToBeAdded(int thisOrNextOrFollowing,
			String[] parts, int a, int currentDayOfWeek, int nextCount,
			int followingCount) {
		int numOfDaysToAdd = 0;
		// If part[a] is a day between monday to sunday
		if (TDTDateMethods.checkDay(parts[a]) <= 7
				&& TDTDateMethods.checkDay(parts[a]) > 0) {
			// Does not have "this", "next" or "following" before the day
			if (thisOrNextOrFollowing == 0) {
				if (TDTDateMethods.checkDay(parts[a]) <= currentDayOfWeek) {
					numOfDaysToAdd = 7 - (currentDayOfWeek - TDTDateMethods
							.checkDay(parts[a]));
				} else {
					numOfDaysToAdd = TDTDateMethods.checkDay(parts[a])
							- currentDayOfWeek;
				}
			} else {// If "this" is before the day
				/*
				 * "this" is taken as the current week If the current day today
				 * is a wednesday, calling this tuesday will refer to the date
				 * which is yesterday.
				 */
				if (TDTDateMethods.checkDay(parts[a]) == 1) {// sunday
					if (currentDayOfWeek != 0) {
						numOfDaysToAdd = 8 - currentDayOfWeek;
					}
				} else {
					numOfDaysToAdd = TDTDateMethods.checkDay(parts[a])
							- currentDayOfWeek;
				}
			}
			// If "next" or "following" is before the day
			if (thisOrNextOrFollowing == 2 || thisOrNextOrFollowing == 3) {
				numOfDaysToAdd = numOfDaysToAdd + (14 * followingCount)
						+ (7 * nextCount);
			}
		} else if (TDTDateMethods.checkDay(parts[a]) == 8) { // today
			// value of numOfDaysToAdd is already 0;
		} else if (TDTDateMethods.checkDay(parts[a]) == 9) { // tomorrow
			numOfDaysToAdd++;
		} else if (TDTDateMethods.checkDay(parts[a]) == 10) { // day
			if (thisOrNextOrFollowing == 2) {// next
				numOfDaysToAdd = numOfDaysToAdd + (1 * nextCount);

			} else if (thisOrNextOrFollowing == 3) {// following
				numOfDaysToAdd = numOfDaysToAdd + (2 * followingCount);
			}
		}
		return numOfDaysToAdd;
	}

	/*
	 * This method does adjustment to the endDate if the startDate is not null.
	 * The endDate is < or = to the startDate due to cases when the user types
	 * in from today to this thursday when today is a friday. Hence this method
	 * adjusts the endDate to thursday of next week.
	 */
	private String adjustmentToDate(boolean endTimeDate, String decodedDate,
			String[] parts, int a) {
		String[] toBeAddedDateParts = decodedDate.split("/");
		if (endTimeDate == true) {
			if (!startDate.equals("null")
					&& TDTDateMethods.checkDay(parts[a]) != 8) {
				// endDate != today
				if (TDTDateMethods.compareToDate(startDate, decodedDate) == -1
						|| TDTDateMethods.compareToDate(startDate, decodedDate) == 0) {
					int dayTemp = Integer.parseInt(toBeAddedDateParts[0]);
					int mthTemp = Integer.parseInt(toBeAddedDateParts[1]);
					int yearTemp = Integer.parseInt(toBeAddedDateParts[2]);

					decodedDate = TDTDateMethods.addDaysToCurrentDate(dayTemp,
							mthTemp, yearTemp, 7);
				}
			}
		}
		return decodedDate;
	}

	// This method decodes the time and converts it to HH:mm time format for
	// storage
	// Time formats: 2am 11pm 2:00am 12:15pm 2345h 2345hr 2345hrs 15:35
	private static String decodeTime(String[] parts, int a) {
		String[] timeParts = new String[2];
		int temp;

		if ((parts[a].substring(parts[a].length() - 2, parts[a].length())
				.equals("am"))
				|| (parts[a]
						.substring(parts[a].length() - 2, parts[a].length())
						.equals("pm") || (parts[a].substring(
						parts[a].length() - 2, parts[a].length()).equals("hr")))) {
			if (parts[a].length() > 4) {
				if (parts[a].charAt(parts[a].length() - 5) == ':'
						|| parts[a].charAt(parts[a].length() - 5) == '.') {
					if (parts[a].length() == 6) {
						timeParts[0] = parts[a].substring(0, 1);
						timeParts[1] = parts[a].substring(2, 4);
					} else {
						timeParts[0] = parts[a].substring(0, 2);
						timeParts[1] = parts[a].substring(3, 5);
					}
				}
			}
			if (parts[a].substring(0, parts[a].length() - 2).matches("\\d+")) {
				if (parts[a].length() == 3 || parts[a].length() == 4) {
					timeParts[0] = parts[a].substring(0, parts[a].length() - 2);
					timeParts[1] = "00";
				} else {
					timeParts[0] = parts[a].substring(0, parts[a].length() - 4);
					timeParts[1] = parts[a].substring(parts[a].length() - 4,
							parts[a].length() - 2);
				}
			}

			temp = Integer.parseInt(timeParts[0]);
			if (parts[a].substring(parts[a].length() - 2, parts[a].length())
					.equals("pm")) {
				if (temp < 12) {
					temp = temp + 12; // convert to 24hrs format
				}
				timeParts[0] = Integer.toString(temp);
			} else if (parts[a].substring(parts[a].length() - 2,
					parts[a].length()).equals("am")) {
				if (temp == 12) {
					timeParts[0] = "00";
				}
			}
		} else if (parts[a].substring(parts[a].length() - 1, parts[a].length())
				.equals("h")) {
			timeParts[0] = parts[a].substring(0, parts[a].length() - 3);
			timeParts[1] = parts[a].substring(parts[a].length() - 3,
					parts[a].length() - 1);
		} else if (parts[a].substring(parts[a].length() - 3, parts[a].length())
				.equals("hrs")) {
			timeParts[0] = parts[a].substring(0, parts[a].length() - 5);
			timeParts[1] = parts[a].substring(parts[a].length() - 5,
					parts[a].length() - 3);
		} else {
			if (parts[a].length() > 2) {
				if (parts[a].charAt(parts[a].length() - 3) == ':'
						|| parts[a].charAt(parts[a].length() - 3) == '.') {
					timeParts[0] = parts[a].substring(0, parts[a].length() - 3);
					timeParts[1] = parts[a].substring(parts[a].length() - 2,
							parts[a].length());
				} else {
					timeParts[0] = parts[a].substring(0, parts[a].length() - 2);
					timeParts[1] = parts[a].substring(parts[a].length() - 2,
							parts[a].length());
				}
			}
		}
		return timeParts[0] + ":" + timeParts[1];
	}

	// This method stores the decoded time to either startTime or endTime
	// depending on the boolean value endTimeDate or deadlineEndTimeDate
	private void storeDecodedTime(boolean endTimeDate,
			boolean deadlineEndTimeDate, String decodedTime) {
		if (deadlineEndTimeDate == true) {
			endTime = decodedTime;
		} else if (endTimeDate == true) {
			if (startTime.equals("null")) {
				startTime = decodedTime;
			} else {
				endTime = decodedTime;
			}
		} else {
			startTime = decodedTime;
		}
	}

	// This method stores the decoded date to either startDate or endDate
	// depending on the boolean value endTimeDate or deadlineEndTimeDate
	private void storeDecodedDate(boolean endTimeDate,
			boolean deadlineEndTimeDate, String decodedDate) {
		// Change the date format to ensure that the date stored follows an
		// uniform date format used by other components.
		decodedDate = TDTDateMethods.changeDateFormat(decodedDate);

		if (deadlineEndTimeDate == true) {
			endDate = decodedDate;
		} else if (endTimeDate == true) {
			if (startDate.equals("null")) {
				startDate = decodedDate;
			} else {
				endDate = decodedDate;
			}
		} else {
			startDate = decodedDate;
		}
	}

	/**
	 * This method parses the search-by-date details.
	 * 
	 * @param searchString
	 * @return String This returns a list of dates in a string to be searched
	 *         from a list of tasks
	 */
	public static String decodeSearchDetails(String searchString) {
		String[] searchParts = searchString.toLowerCase().split(" ");
		int thisOrNextOrFollowing = 0; // this = 1 next = 2 following = 3
		String decodedSearchString = "";
		String decodedDate = "";
		int nextCount = 0;
		int followingCount = 0;
		String startSearchDate = "";
		String endSearchDate = "";
		boolean isSearchDateRange = false;
		// Get current date
		cal = Calendar.getInstance(TimeZone.getDefault());
		int currentDay = cal.get(Calendar.DATE);
		int currentMonth = cal.get(Calendar.MONTH) + 1;
		int currentYear = cal.get(Calendar.YEAR);
		int currentDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
		int currentDayOfMonth = cal.get(Calendar.DAY_OF_MONTH);

		for (int i = 0; i < searchParts.length; i++) {
			searchParts[i] = TDTCommons
					.replaceEndStringPunctuation(searchParts[i]);

			if (isPrepositionTo(searchParts, i) && !startSearchDate.equals("")) {
				isSearchDateRange = true;
			}

			if (searchParts[i].equals("this")) {
				thisOrNextOrFollowing = 1;
			} else if (searchParts[i].equals("next")) {
				nextCount++;
				thisOrNextOrFollowing = 2;
			} else if (searchParts[i].equals("following")) {
				followingCount++;
				thisOrNextOrFollowing = 3;
			}

			if (TDTDateMethods.checkDate(searchParts[i])) {
				decodedDate = decodeDate(searchParts, i, currentYear,
						currentMonth);
				if (TDTDateMethods.isValidDateRange(decodedDate)) {
					decodedDate = TDTDateMethods.changeDateFormat(decodedDate);
				}
				if (isSearchDateRange) {
					endSearchDate = decodedDate;
				} else {
					startSearchDate = decodedDate;
				}
				decodedSearchString = decodedSearchString + decodedDate + " ";
			} else if (TDTDateMethods.checkDay(searchParts[i]) != 0) {
				int numOfDaysToAdd = determineDaysToBeAdded(
						thisOrNextOrFollowing, searchParts, i,
						currentDayOfWeek, nextCount, followingCount);
				decodedDate = TDTDateMethods.addDaysToCurrentDate(currentDay,
						currentMonth, currentYear, numOfDaysToAdd);
				if (TDTDateMethods.isValidDateRange(decodedDate)) {
					decodedDate = TDTDateMethods.changeDateFormat(decodedDate);
				}
				if (isSearchDateRange) {
					endSearchDate = decodedDate;
				} else {
					startSearchDate = decodedDate;
				}
				decodedSearchString = decodedSearchString + decodedDate + " ";
			} else if (TDTDateMethods.checkMonth(searchParts[i]) != 0) {
				// Date format: 14 aug 2014, 14 aug 14
				decodedDate = decodeSearchMonthFormat(searchParts, decodedDate,
						i);
				if (isSearchDateRange) {
					endSearchDate = decodedDate;
				} else {
					startSearchDate = decodedDate;
				}
				decodedSearchString = decodedSearchString + decodedDate + " ";
			} else if (TDTDateMethods.checkWeekMonthYear(searchParts[i]) != 0) {
				if (TDTDateMethods.checkWeekMonthYear(searchParts[i]) == 1) {
					// this week next week following week
					decodedSearchString = searchWeek(thisOrNextOrFollowing,
							decodedSearchString, currentDay, currentMonth,
							currentYear, currentDayOfWeek, nextCount,
							followingCount);
				} else if (TDTDateMethods.checkWeekMonthYear(searchParts[i]) == 2) {
					// this month next month following month
					decodedSearchString = searchMonth(thisOrNextOrFollowing,
							decodedSearchString, currentDay, currentMonth,
							currentYear, currentDayOfMonth, nextCount,
							followingCount);
				} else if (TDTDateMethods.checkWeekMonthYear(searchParts[i]) == 3) {
					// this year next year following year
					decodedSearchString = searchYear(thisOrNextOrFollowing,
							decodedSearchString, currentYear, nextCount,
							followingCount);
				}
			}
			// search by a date range eg. 22/12/14 to 29/12/14
			if (isSearchDateRange && !endSearchDate.equals("")) {
				if (TDTDateMethods.isValidDateRange(startSearchDate)
						&& TDTDateMethods.isValidDateRange(endSearchDate)) {
					if (TDTDateMethods.compareToDate(startSearchDate,
							endSearchDate) == 1) {
						decodedSearchString = searchDateRange(
								decodedSearchString, startSearchDate,
								endSearchDate);
					}
				}
				// resets the values so as to take in another range of dates
				isSearchDateRange = false;
				startSearchDate = "";
				endSearchDate = "";
			}
		}
		return decodedSearchString.trim();
	}

	// This method detects a valid month and checks the word before and after.
	// If it detects a valid date format that follow dd MMM YYYY or dd MMM YY,
	// it converts it to date format DD/MM/YYYY
	private static String decodeSearchMonthFormat(String[] searchParts,
			String decodedDate, int i) {
		boolean isValidDayYear = true;
		// Prevents null pointer exception
		if (i != 0 && i != searchParts.length - 1) {
			String before = searchParts[i - 1];
			String after = searchParts[i + 1];
			try {
				Integer.parseInt(before);
				Integer.parseInt(after);
			} catch (NumberFormatException e) {
				isValidDayYear = false;
			}
			if (isValidDayYear) {
				int day = Integer.parseInt(before);
				int month = TDTDateMethods.checkMonth(searchParts[i]);
				int year = 0;

				if (after.length() == 2) {
					after = "20" + after;
				}
				year = Integer.parseInt(after);

				decodedDate = day + "/" + month + "/" + year;
				if (TDTDateMethods.isValidDateRange(decodedDate)) {
					decodedDate = TDTDateMethods.changeDateFormat(decodedDate);
				}
			}
		}
		return decodedDate;
	}

	// This method creates a list of dates concat in a string to be searched in
	// between the range of dates.
	private static String searchDateRange(String decodedSearchString,
			String startSearchDate, String endSearchDate) {
		String dateTemp = "";
		dateTemp = startSearchDate;
		while (!dateTemp.equals(endSearchDate)) {
			String[] dateParts = dateTemp.split("/");
			int dayTemp = Integer.parseInt(dateParts[0]);
			int monthTemp = Integer.parseInt(dateParts[1]);
			int yearTemp = Integer.parseInt(dateParts[2]);
			dateTemp = TDTDateMethods.addDaysToCurrentDate(dayTemp, monthTemp,
					yearTemp, 1);
			decodedSearchString = decodedSearchString + dateTemp + " ";
		}
		return decodedSearchString;
	}

	// This method creates a list of dates concat in a string to be searched in
	// a specific week
	private static String searchWeek(int thisOrNextOrFollowing,
			String decodedSearchString, int currentDay, int currentMonth,
			int currentYear, int currentDayOfWeek, int nextCount,
			int followingCount) {
		int dayOfWeek = currentDayOfWeek;
		String startDayOfWeek = TDTDateMethods.addDaysToCurrentDate(currentDay,
				currentMonth, currentYear,
				Integer.parseInt("-" + (dayOfWeek - 1)));
		String[] dateParts;
		String dateTemp;
		dateParts = startDayOfWeek.split("/");
		int dayTemp = Integer.parseInt(dateParts[0]);
		int monthTemp = Integer.parseInt(dateParts[1]);
		int yearTemp = Integer.parseInt(dateParts[2]);

		// Determines the week to be searched
		if (thisOrNextOrFollowing == 0) {
			return decodedSearchString;
		} else if (thisOrNextOrFollowing == 2 || thisOrNextOrFollowing == 3) {
			startDayOfWeek = TDTDateMethods.addDaysToCurrentDate(dayTemp,
					monthTemp, yearTemp, (7 * nextCount)
							+ (14 * followingCount));
		}
		decodedSearchString = decodedSearchString + startDayOfWeek + " ";
		dateTemp = startDayOfWeek;
		// Creates the list of dates after the week is determined
		// The list of dates is created starting from the first day of the week,
		// sunday
		for (int z = 0; z < 6; z++) {
			dateParts = dateTemp.split("/");
			dayTemp = Integer.parseInt(dateParts[0]);
			monthTemp = Integer.parseInt(dateParts[1]);
			yearTemp = Integer.parseInt(dateParts[2]);

			dateTemp = TDTDateMethods.addDaysToCurrentDate(dayTemp, monthTemp,
					yearTemp, 1);
			decodedSearchString = decodedSearchString + dateTemp + " ";
		}
		return decodedSearchString;
	}

	// This method creates a list of dates concat in a string to be searched in
	// a specific month
	private static String searchMonth(int thisOrNextOrFollowing,
			String decodedSearchString, int currentDay, int currentMonth,
			int currentYear, int currentDayOfMonth, int nextCount,
			int followingCount) {
		int dayOfMonth = currentDayOfMonth - 1;
		String startDayOfMonth = TDTDateMethods.addDaysToCurrentDate(
				currentDay, currentMonth, currentYear,
				Integer.parseInt("-" + dayOfMonth));
		String[] dateParts;
		String dateTemp = "";
		dateParts = startDayOfMonth.split("/");
		int dayTemp = Integer.parseInt(dateParts[0]);
		int monthTemp = Integer.parseInt(dateParts[1]);
		int yearTemp = Integer.parseInt(dateParts[2]);

		// Determines the month to be searched
		if (thisOrNextOrFollowing == 0) {
			return decodedSearchString;
		} else if (thisOrNextOrFollowing == 2 || thisOrNextOrFollowing == 3) {
			int numOfMthToAdd = nextCount + followingCount * 2;
			for (int i = 0; i < numOfMthToAdd; i++) {
				if (monthTemp == 12) {
					monthTemp = 1;
					yearTemp = yearTemp + 1;
				} else {
					monthTemp++;
				}
			}
			startDayOfMonth = dayTemp + "/" + monthTemp + "/" + yearTemp;
		}

		decodedSearchString = decodedSearchString + startDayOfMonth + " ";
		dateTemp = startDayOfMonth;
		dateParts = dateTemp.split("/");

		// Creates the list of dates after the month is determined
		// The list of dates is created starting from the first day of the month
		if (dateParts.length == 3) { // ensure dateTemp not = ""
			int numDayOfMonth = TDTDateMethods.getNumOfDaysFromMonth(
					Integer.parseInt(dateParts[1]),
					Integer.parseInt(dateParts[2]));
			for (int z = 0; z < numDayOfMonth - 1; z++) {
				dateParts = dateTemp.split("/");
				dayTemp = Integer.parseInt(dateParts[0]);
				monthTemp = Integer.parseInt(dateParts[1]);
				yearTemp = Integer.parseInt(dateParts[2]);

				dateTemp = TDTDateMethods.addDaysToCurrentDate(dayTemp,
						monthTemp, yearTemp, 1);
				decodedSearchString = decodedSearchString + dateTemp + " ";
			}
		}
		return decodedSearchString;
	}

	// This method creates a list of dates concat in a string to be searched in
	// a specific year
	private static String searchYear(int thisOrNextOrFollowing,
			String decodedSearchString, int currentYear, int nextCount,
			int followingCount) {
		int yearTemp = currentYear;
		// Determines the year to be searched
		if (thisOrNextOrFollowing == 0) {
			return decodedSearchString;
		} else if (thisOrNextOrFollowing == 2 || thisOrNextOrFollowing == 3) {
			yearTemp = yearTemp + (nextCount + followingCount * 2);
		}
		// Creates the list of dates after the year is determined
		// The list of dates is created starting from the first day of the year
		for (int a = 1; a <= 12; a++) {
			int numDayOfMonth = TDTDateMethods.getNumOfDaysFromMonth(a,
					yearTemp);
			for (int b = 1; b <= numDayOfMonth; b++) {
				String date = b + "/" + a + "/" + yearTemp;
				decodedSearchString = decodedSearchString + date + " ";
			}
		}
		return decodedSearchString;
	}

	/**
	 * This method parses the set-reminder details to get the reminder date and
	 * time with the correct formats used in storage.
	 * 
	 * @param reminderString
	 * @return String This returns a string of date and time concat together.
	 */
	public static String decodeReminderDetails(String reminderString) {
		String[] reminderParts = reminderString.toLowerCase().split(" ");
		int thisOrNextOrFollowing = 0; // this = 1 next = 2 following = 3
		String decodedReminderDate = "null";
		String decodedReminderTime = "null";
		int nextCount = 0;
		int followingCount = 0;
		// Get current date and time
		cal = Calendar.getInstance(TimeZone.getDefault());
		int currentDay = cal.get(Calendar.DATE);
		int currentMonth = cal.get(Calendar.MONTH) + 1;
		int currentYear = cal.get(Calendar.YEAR);
		int currentDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);

		int currentHour = cal.get(Calendar.HOUR_OF_DAY);
		int currentMinute = cal.get(Calendar.MINUTE);

		String currentTime = currentHour + ":" + currentMinute;
		String currentDate = currentDay + "/" + currentMonth + "/"
				+ currentYear;

		for (int i = 0; i < reminderParts.length; i++) {
			reminderParts[i] = TDTCommons
					.replaceEndStringPunctuation(reminderParts[i]);

			if (reminderParts[i].equals("this")) {
				thisOrNextOrFollowing = 1;
			} else if (reminderParts[i].equals("next")) {
				nextCount++;
				thisOrNextOrFollowing = 2;
			} else if (reminderParts[i].equals("following")) {
				followingCount++;
				thisOrNextOrFollowing = 3;
			}

			if (TDTDateMethods.checkDate(reminderParts[i])) {
				decodedReminderDate = decodeDate(reminderParts, i, currentYear,
						currentMonth);
			} else if (TDTDateMethods.checkDay(reminderParts[i]) != 0) {
				int numOfDaysToAdd = determineDaysToBeAdded(
						thisOrNextOrFollowing, reminderParts, i,
						currentDayOfWeek, nextCount, followingCount);
				decodedReminderDate = TDTDateMethods.addDaysToCurrentDate(
						currentDay, currentMonth, currentYear, numOfDaysToAdd);
			} else if (TDTDateMethods.checkMonth(reminderParts[i]) != 0) {
				decodedReminderDate = decodeRemindMonthFormat(reminderParts,
						decodedReminderDate, i);
			} else if (TDTTimeMethods.checkTime(reminderParts[i])) {
				decodedReminderTime = decodeTime(reminderParts, i);
			}
		}

		if (decodedReminderTime.equals("null")) {
			return "null";
		} else if (decodedReminderDate.equals("null")) {
			// date is taken as the current date
			if (TDTTimeMethods.compareToTime(currentTime, decodedReminderTime) == 1) {
				// ReminderTime has to be after currentTime if date is current
				// date
				return currentDate + " " + decodedReminderTime;
			}
		} else {
			if (TDTDateMethods.isValidDateRange(decodedReminderDate)) {
				if (TDTDateMethods.compareToDate(currentDate,
						decodedReminderDate) == 0) {
					if (TDTTimeMethods.compareToTime(currentTime,
							decodedReminderTime) == 1) {
						return decodedReminderDate + " " + decodedReminderTime;
					}
				} else if (TDTDateMethods.compareToDate(currentDate,
						decodedReminderDate) == 1) {
					return decodedReminderDate + " " + decodedReminderTime;
				}
			}
		}
		return "null";
	}

	// This method detects a valid month and checks the word before and after.
	// If it detects a valid date format that follow dd MMM YYYY or dd MMM YY,
	// it converts it to date format DD/MM/YYYY
	private static String decodeRemindMonthFormat(String[] reminderParts,
			String decodedReminderDate, int i) {
		boolean isValidDayYear = true;
		if (i != 0 && i != reminderParts.length - 1) {
			String before = reminderParts[i - 1];
			int month = TDTDateMethods.checkMonth(reminderParts[i]);
			String after = reminderParts[i + 1];
			try {
				Integer.parseInt(before);
				Integer.parseInt(after);
			} catch (NumberFormatException e) {
				isValidDayYear = false;
			}
			if (isValidDayYear) {
				int day = Integer.parseInt(before);
				int year = 0;

				if (after.length() == 2) {
					after = "20" + after;
				}
				year = Integer.parseInt(after);

				decodedReminderDate = day + "/" + month + "/" + year;
			} else {
				decodedReminderDate = before + "/" + month + "/" + after;
			}
		}
		return decodedReminderDate;
	}
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\logic\parser\TDTDateAndTimeParser.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTDateAndTimeParserTest.java
	 */

package todothis.test;

import static org.junit.Assert.*;

import org.junit.Test;

import todothis.commons.TDTDateAndTime;
import todothis.logic.parser.TDTDateAndTimeParser;

/**
 * 
 * This class tests the methods in TDTDateAndTimeParser.
 *
 */
public class TDTDateAndTimeParserTest {
	private TDTDateAndTime test = new TDTDateAndTime();
	private TDTDateAndTimeParser testParser = new TDTDateAndTimeParser();

	@Test
	public void testDecodeDateAndTimeDetails() {
		// Checks if the date and time info are stored correctly in the right
		// place

		// Deadline Task
		test = testParser.decodeDateAndTimeDetails("by 12/11/14 10pm");
		assertEquals(test.getStartDate(), "null");
		assertEquals(test.getStartTime(), "null");
		assertEquals(test.getEndDate(), "12/11/2014");
		assertEquals(test.getEndTime(), "22:00");

		testParser = new TDTDateAndTimeParser(); // resets the variable values
		test = testParser.decodeDateAndTimeDetails("before 2345hr");
		assertEquals(test.getStartDate(), "null");
		assertEquals(test.getStartTime(), "null");
		assertEquals(test.getEndDate(), "null");
		assertEquals(test.getEndTime(), "23:45");

		testParser = new TDTDateAndTimeParser();
		test = testParser.decodeDateAndTimeDetails("due 13/12");
		assertEquals(test.getStartDate(), "null");
		assertEquals(test.getStartTime(), "null");
		assertEquals(test.getEndDate(), "13/12/2014");
		assertEquals(test.getEndTime(), "null");

		// Floating Task
		testParser = new TDTDateAndTimeParser();
		test = testParser.decodeDateAndTimeDetails("");
		assertEquals(test.getStartDate(), "null");
		assertEquals(test.getStartTime(), "null");
		assertEquals(test.getEndDate(), "null");
		assertEquals(test.getEndTime(), "null");

		// Timed Task
		testParser = new TDTDateAndTimeParser();
		test = testParser
				.decodeDateAndTimeDetails("10/11/14 from 1200h - 1400hr");
		assertEquals(test.getStartDate(), "10/11/2014");
		assertEquals(test.getStartTime(), "12:00");
		assertEquals(test.getEndDate(), "10/11/2014");
		assertEquals(test.getEndTime(), "14:00");

		testParser = new TDTDateAndTimeParser();
		test = testParser
				.decodeDateAndTimeDetails("from 1200h - 1400hr on 12122014");
		assertEquals(test.getStartDate(), "12/12/2014");
		assertEquals(test.getStartTime(), "12:00");
		assertEquals(test.getEndDate(), "12/12/2014");
		assertEquals(test.getEndTime(), "14:00");

		testParser = new TDTDateAndTimeParser();
		test = testParser
				.decodeDateAndTimeDetails("from 10/12 9am until 15/12 10pm");
		assertEquals(test.getStartDate(), "10/12/2014");
		assertEquals(test.getStartTime(), "9:00");
		assertEquals(test.getEndDate(), "15/12/2014");
		assertEquals(test.getEndTime(), "22:00");

		testParser = new TDTDateAndTimeParser();
		test = testParser.decodeDateAndTimeDetails("on 11/12/14 9.30pm");
		assertEquals(test.getStartDate(), "11/12/2014");
		assertEquals(test.getStartTime(), "21:30");
		assertEquals(test.getEndDate(), "null");
		assertEquals(test.getEndTime(), "null");
	}

	// As this method makes use of the current date and time, this test will
	// only pass at the specific time of testing
	// @Test
	public void testDecodeSearchDetails() {
		// test search by range of dates eg. 10/10/2014 - 11/11/2014
		assertEquals(
				TDTDateAndTimeParser
						.decodeSearchDetails("28/10/2014 - 6/11/2014"),
				"28/10/2014 6/11/2014 29/10/2014 30/10/2014 31/10/2014 1/11/2014 2/11/2014 3/11/2014 4/11/2014 5/11/2014 6/11/2014");
		assertEquals(
				TDTDateAndTimeParser
						.decodeSearchDetails("28/10/2014 - 15/10/2014"),
				"28/10/2014 15/10/2014");

		// test search a string of dates eg. 10/10/2014, 16/10/2014, 5/1/2015
		assertEquals(
				TDTDateAndTimeParser
						.decodeSearchDetails("10/10/14 16/10/14 5/1/2015"),
				"10/10/2014 16/10/2014 5/1/2015");

		// test search by week month or year
		// Test done at 10/11/2014 mon
		assertEquals(TDTDateAndTimeParser.decodeSearchDetails("this week"),
				"9/11/2014 10/11/2014 11/11/2014 12/11/2014 13/11/2014 14/11/2014 15/11/2014");

		assertEquals(
				TDTDateAndTimeParser.decodeSearchDetails("next month"),
				"1/12/2014 2/12/2014 3/12/2014 4/12/2014 5/12/2014 6/12/2014 7/12/2014 8/12/2014 9/12/2014 10/12/2014 11/12/2014 12/12/2014 13/12/2014 14/12/2014 15/12/2014 16/12/2014 17/12/2014 18/12/2014 19/12/2014 20/12/2014 21/12/2014 22/12/2014 23/12/2014 24/12/2014 25/12/2014 26/12/2014 27/12/2014 28/12/2014 29/12/2014 30/12/2014 31/12/2014");

	}

	// As this method makes use of the current date and time, this test will
	// only pass at the specific time of testing
	// @Test
	public void testDecodeReminderDetails() {
		// checks if user types only the time
		// Testing date and time: 4.00pm 10/11/2014
		assertEquals(TDTDateAndTimeParser.decodeReminderDetails("6pm"),
				"10/11/2014 18:00");
		// if user input a time that is over, the reminder details will be
		// invalid
		assertEquals(TDTDateAndTimeParser.decodeReminderDetails("2pm"), "null");

		// if user input a date and a time
		assertEquals(
				TDTDateAndTimeParser.decodeReminderDetails("15/11/14 2pm"),
				"15/11/2014 14:00");
		// if user input a date and time that is over
		assertEquals(TDTDateAndTimeParser.decodeReminderDetails("9/11/14 2pm"),
				"null");
	}

}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTDateAndTimeParserTest.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTDateAndTimeTest.java
	 */

package todothis.test;
import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

import todothis.commons.TDTDateAndTime;

/**
 * 
 * This class tests the TDTDateAndTime class methods.
 *
 */
public class TDTDateAndTimeTest {
	// As this method makes use of the current date and time, this test will
	// only pass at the specific time of testing
	//@Test
	public void testOverDue(){
		ArrayList<TDTDateAndTime> taskList = new ArrayList<TDTDateAndTime>();
		// TDTDateAndTime(String startDate, String endDate, String startTime, String endTime)
		//Test Done on 22/10/2014 5pm
		
		//Testing deadline task
		taskList.add(new TDTDateAndTime("null", "22/10/2014", "null", "16:59"));
		//This is the boundary case for dueTime before currentTime partition
		assertTrue(taskList.get(0).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("null", "22/10/2014", "null", "17:01")); 
		//This is the boundary case for dueTime after currentTime partition
		assertFalse(taskList.get(1).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("null", "22/10/2014", "null", "17:00")); 
		//This is the boundary case for dueTime on currentTime partition
		assertFalse(taskList.get(2).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("null", "21/10/2014", "null", "null")); 
		//This is the boundary case for dueDate before currentDate partition
		assertTrue(taskList.get(3).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("null", "23/10/2014", "null", "null")); 
		//This is the boundary case for dueDate after currentDate partition
		assertFalse(taskList.get(4).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("null", "22/10/2014", "null", "null")); 
		//This is the boundary case for dueDate on currentDate partition
		assertFalse(taskList.get(5).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("null", "null", "null", "15:00")); 
		//This is the case where only dueTime is keyed, taken care the whole partition
		assertFalse(taskList.get(6).isOverdue()); 
		
		
		//Testing timed task Eg: on a single day with a start and end time
		taskList.add(new TDTDateAndTime("22/10/2014", "null", "11:00", "16:59")); 
		//This is the boundary case for endTime before currentTime partition
		assertTrue(taskList.get(7).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("22/10/2014", "null", "11:00", "17:01")); 
		//This is the boundary case for endTime after currentTime partition
		assertFalse(taskList.get(8).isOverdue());
		
		taskList.add(new TDTDateAndTime("22/10/2014", "null", "11:00", "17:00")); 
		//This is the boundary case for endTime on currentTime partition
		assertFalse(taskList.get(9).isOverdue()); 
		
		
		//Testing timed task Eg: a span of more than 1 day with a start and end time
		taskList.add(new TDTDateAndTime("20/10/2014", "21/10/2014", "11:00", "16:59")); 
		//This is the boundary case for endDate before currentDate partition
		assertTrue(taskList.get(10).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("20/10/2014", "22/10/2014", "11:00", "16.59")); 
		//This is the boundary case for endDate same currentDate partition, endTime is checked
		assertTrue(taskList.get(11).isOverdue()); 
		
		taskList.add(new TDTDateAndTime("20/10/2014", "23/10/2014", "11:00", "17:00")); 
		//This is the boundary case for endDate after currentDate partition
		assertFalse(taskList.get(12).isOverdue()); 
		
	}
	
	@Test
	public void testCompareTo(){
		int numTask = 100;
		TDTDateAndTime[] taskList = new TDTDateAndTime[numTask];
		
		//compareTo 2 timed tasks
		//tasks with same start date but different or same timing
		taskList[0] = new TDTDateAndTime("13/10/2014", "13/10/2014", "18:00", "20:00");
		taskList[1] = new TDTDateAndTime("13/10/2014", "15/10/2014", "18:00", "22:00");
		assertEquals(taskList[0].compareTo(taskList[1]), 0);
		
		taskList[2] = new TDTDateAndTime("13/10/2014", "13/10/2014", "18:04", "18:05");
		taskList[3] = new TDTDateAndTime("13/10/2014", "14/10/2014", "12:00", "14:00");
		assertEquals(taskList[2].compareTo(taskList[3]), 1);
		
		taskList[4] = new TDTDateAndTime("13/10/2014", "14/10/2014", "12:59", "13:59");
		taskList[5] = new TDTDateAndTime("13/10/2014", "14/10/2014", "23:58", "13:59");
		assertEquals(taskList[4].compareTo(taskList[5]), -1);
		
		//tasks with different start date, time doesn't matter
		taskList[6] = new TDTDateAndTime("15/10/2014", "20/10/2014", "19:00", "22:00");
		taskList[7] = new TDTDateAndTime("13/10/2014", "15/10/2015", "18:00", "20:00");
		assertEquals(taskList[6].compareTo(taskList[7]), 1);
		
		taskList[8] = new TDTDateAndTime("12/10/2014", "13/10/2014", "19:00", "21:00");
		taskList[9] = new TDTDateAndTime("13/10/2014", "13/10/2014", "18:05", "19:55");
		assertEquals(taskList[8].compareTo(taskList[9]), -1);
		
		//compareTo 2 deadline tasks of same date
		taskList[10] = new TDTDateAndTime("null", "15/10/2014", "null", "02:00");
		taskList[11] = new TDTDateAndTime("null", "15/10/2014", "null", "01:00");
		assertEquals(taskList[10].compareTo(taskList[11]), 1);
		
		taskList[12] = new TDTDateAndTime("null", "15/10/2014", "null", "02:00");
		taskList[13] = new TDTDateAndTime("null", "15/10/2014", "null", "09:00");
		assertEquals(taskList[12].compareTo(taskList[13]), -1);
		
		//compareTo a timed task and a deadline task
		taskList[14] = new TDTDateAndTime("null", "15/10/2014", "null", "02:00");
		taskList[15] = new TDTDateAndTime("14/10/2014", "15/10/2014", "01:00", "09:00");
		assertEquals(taskList[14].compareTo(taskList[15]), 1);
		
		taskList[16] = new TDTDateAndTime("null", "15/10/2014", "null", "02:00");
		taskList[17] = new TDTDateAndTime("16/10/2014", "20/10/2014", "01:00", "09:00");
		assertEquals(taskList[16].compareTo(taskList[17]), -1);
		
		//compareTo a timed task and a floating task
		taskList[16] = new TDTDateAndTime("null", "null", "null", "null");
		taskList[17] = new TDTDateAndTime("16/10/2014", "21/10/2014", "01:00", "09:00");
		assertEquals(taskList[16].compareTo(taskList[17]), 1);
		
		//compareTo a deadline task and a floating task
		taskList[18] = new TDTDateAndTime("null", "null", "null", "null");
		taskList[19] = new TDTDateAndTime("null", "21/10/2014", "null", "09:00");
		assertEquals(taskList[18].compareTo(taskList[19]), 1);
	}
	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTDateAndTimeTest.java





	/**
	 * origin: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTDateMethodsTest.java
	 */

package todothis.test;

import static org.junit.Assert.*;

import org.junit.Test;

import todothis.commons.TDTDateMethods;
/**
 * This class tests methods in TDTDateMethods class.
 *
 */

public class TDTDateMethodsTest {
	@Test
	public void testCheckDate(){
		//Check for date format: DDMMYY
		
		//This is boundary case for date of length 6
		assertTrue(TDTDateMethods.checkDate("120814")); 
		//This is boundary case for date of length more than 6
		assertFalse(TDTDateMethods.checkDate("1208143")); 
		 //This is boundary case for date of length less than 6
		assertFalse(TDTDateMethods.checkDate("12814"));
		//This is case when date consist of not all digits
		assertFalse(TDTDateMethods.checkDate("2a0814")); 
		
		//Check for date format: DDMMYYYY 
		//Similar to DDMMYY testing OMITTED
		
		//Check for date format: DD-MM-YYYY, DD-MM
		
		 //This is a case that follows the date format
		assertTrue(TDTDateMethods.checkDate("12-2-14"));
		//This is a case that follows the date format
		assertTrue(TDTDateMethods.checkDate("12-1")); 
		//This is a boundary case for having more than 2 dashes
		assertFalse(TDTDateMethods.checkDate("12-1-14-1")); 
		//this is a case when date consist of not all digits
		assertFalse(TDTDateMethods.checkDate("1a-12-14")); 
		
		//Check for date format: DD/MM/YYYY, DD/MM
		//Similar to DD-MM-YYYY OMITTED
	}
	
	@Test
	public void testAddDaysToDate(){
		//This cases test adding and subtracting of less than 31 days within the month
		assertEquals(TDTDateMethods.addDaysToCurrentDate(10, 11, 2014, 10), "20/11/2014");
		assertEquals(TDTDateMethods.addDaysToCurrentDate(10, 11, 2014, -9), "1/11/2014");
		
		//This cases test adding and subtracting of more than 31 days
		assertEquals(TDTDateMethods.addDaysToCurrentDate(10, 11, 2014, 30), "10/12/2014");
		assertEquals(TDTDateMethods.addDaysToCurrentDate(10, 11, 2014, -30), "11/10/2014");
		
		//This cases test adding and subtracting of days over the year
		assertEquals(TDTDateMethods.addDaysToCurrentDate(31, 12, 2014, 2), "2/1/2015");
		assertEquals(TDTDateMethods.addDaysToCurrentDate(1, 1, 2014, -2), "30/12/2013");
	}
	
	@Test 
	public void testChangeToDayOfWeek(){
		assertEquals(TDTDateMethods.changeToDayOfWeek("10/11/2014"),"Mon");
	}
	@Test 
	public void testChangeDateFormat(){
		assertEquals(TDTDateMethods.changeDateFormat("01/11/2014"),"1/11/2014");
	}
	@Test 
	public void testChangeDateFormatDisplay(){
		assertEquals(TDTDateMethods.changeDateFormatDisplay("01/11/2014"),"1 Nov 2014");
	}
	@Test
	public void testValidDateRange(){
		//This is boundary case for year lesser than 2014 partition
		assertFalse(TDTDateMethods.isValidDateRange("12/12/2013"));
		//This is boundary case for year within range partition
		assertTrue(TDTDateMethods.isValidDateRange("12/12/2050"));
		//This is boundary case for year more than 2099 partition
		assertFalse(TDTDateMethods.isValidDateRange("12/12/2100"));
		
		//This is boundary case for month lesser than 1 partition
		assertFalse(TDTDateMethods.isValidDateRange("12/0/2014"));
		//This is boundary case for month within range partition
		assertTrue(TDTDateMethods.isValidDateRange("12/8/2014"));
		//This is boundary case for month more than 12 partition
		assertFalse(TDTDateMethods.isValidDateRange("12/13/2014"));
		
		//This is boundary case for day lesser than 1 partition
		assertFalse(TDTDateMethods.isValidDateRange("0/8/2014"));
		//This is boundary case for day within range partition
		assertTrue(TDTDateMethods.isValidDateRange("12/8/2014"));
		//This is boundary case for day more than 31 partition
		assertFalse(TDTDateMethods.isValidDateRange("32/8/2014"));
		
		//This is case when date is not initialized
		assertTrue(TDTDateMethods.isValidDateRange("null"));
		//This is case when date has unwanted non digits
		assertFalse(TDTDateMethods.isValidDateRange("a31/8/2014")); 
		
	}
	@Test
	public void testCompareToDate(){
		//This are cases that test within the same month
		assertEquals(TDTDateMethods.compareToDate("10/11/2014", "10/11/2014"), 0);
		assertEquals(TDTDateMethods.compareToDate("10/11/2014", "11/11/2014"), 1);
		assertEquals(TDTDateMethods.compareToDate("11/11/2014", "10/11/2014"), -1);
		
		//This are cases that test within the same year
		assertEquals(TDTDateMethods.compareToDate("10/10/2014", "11/11/2014"), 1);
		assertEquals(TDTDateMethods.compareToDate("1/12/2014", "10/11/2014"), -1);
		
		//This are cases that test dates of different years
		assertEquals(TDTDateMethods.compareToDate("10/10/2013", "11/11/2014"), 1);
		assertEquals(TDTDateMethods.compareToDate("1/12/2019", "10/11/2014"), -1);
	}
}

	// End of segment: C:\Users\Justin\Downloads\Collate V2.0\todothis\test\TDTDateMethodsTest.java





